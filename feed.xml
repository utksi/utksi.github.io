<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://utksi.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://utksi.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-30T18:45:45+00:00</updated><id>https://utksi.github.io/feed.xml</id><title type="html">blank</title><subtitle>Worklog and thoughts </subtitle><entry><title type="html">ELF, with wannier functions</title><link href="https://utksi.github.io/blog/2024/wannier_elf/" rel="alternate" type="text/html" title="ELF, with wannier functions"/><published>2024-12-12T02:14:00+00:00</published><updated>2024-12-12T02:14:00+00:00</updated><id>https://utksi.github.io/blog/2024/wannier_elf</id><content type="html" xml:base="https://utksi.github.io/blog/2024/wannier_elf/"><![CDATA[<ul> <li> <p>This is not complete - in the sense that it is something, but no one yet knows if it is useful to have.</p> </li> <li> <p>For a primer on wannier functions: please see <a href="https://arxiv.org/abs/2312.10769">this</a>.</p> </li> <li> <p>In the event reading the following is not really needed, the implementation is available here: <a href="https://github.com/utksi/wannier_elf">Wannier-ELF</a></p> </li> </ul> <hr/> <h3 id="what-and-why"><strong>What, and Why?</strong></h3> <p>The Electron Localization Function (ELF) is a valuable tool in computational chemistry and condensed matter physics for visualizing and understanding electron localization in atoms, molecules, and solids.</p> <p>Speaking informally, if one knows the degree of electron localization, a more generalized (as opposed to localized :D) perspective of bonding in the material of interest should be obtained. It is somewhat easier to think of this when looking at the math:</p> <p>The standard expression for ELF involves the kinetic energy densities:</p> \[\text{ELF}(\mathbf{r}) = \dfrac{1}{1 + \left( \dfrac{ t_P(\mathbf{r}) }{ t_h(\mathbf{r}) } \right)^2}\] <ul> <li>\(t_P(\mathbf{r}) = t(\mathbf{r}) - t_W(\mathbf{r})\): Pauli kinetic energy density.</li> <li>\(t(\mathbf{r})\): Total kinetic energy density.</li> <li>\(t_W(\mathbf{r})\): von Weizsäcker kinetic energy density.</li> <li>\(t_h(\mathbf{r})\): Kinetic energy density of a homogeneous electron gas.</li> </ul> <p>Essentially, it is a three-dimensional scalar field that <strong>tracks the variation in KE density</strong> (Total - Von-Weizsäcker term) at some point \(\mathbf{\vec{r}}\) in the cell, compared to if one had a homogeneous electron gas with the same electron density, for which the gradient term: \(\nabla n(\mathbf{r})\) should be exactly zero.</p> <p>This ratio: \(\dfrac{ t_P(\mathbf{r}) }{ t_h(\mathbf{r}) }\) is also sometimes called the <strong>localization index</strong> : \(\chi (r)\).</p> <p>Given \(n(\mathbf{r})\): the electron density.</p> <ol> <li> <p><strong>von Weizsäcker Kinetic Energy Density:</strong> \(t_W(\mathbf{r}) = \dfrac{1}{8} \dfrac{|\nabla n(\mathbf{r})|^2}{n(\mathbf{r})}\)</p> </li> <li> <p><strong>Pauli Kinetic Energy Density:</strong> \(t_P(\mathbf{r}) = t(\mathbf{r}) - t_W(\mathbf{r})\)</p> </li> <li> <p><strong>Homogeneous Electron Gas Kinetic Energy Density:</strong> \(t_h(\mathbf{r}) = \dfrac{3}{5} (3\pi^2)^{2/3} [n(\mathbf{r})]^{5/3}\)</p> </li> </ol> <hr/> <h3 id="vaspcastep-expressions-for-elf">VASP/CASTEP expressions for ELF</h3> <p>If you’re reading this, then it’s highly likely that you already know that ELF fields can be written very easily after a obtaining charge density in VASP/CASTEP.</p> <p>And, in CASTEP and VASP, the ELF is calculated using an expression involving the Laplacian of the Kohn-Sham orbitals and electron density:</p> \[D(\mathbf{r}) = -2A \sum_i \psi_i^*(\mathbf{r}) \nabla^2 \psi_i(\mathbf{r}) + \dfrac{A}{2} \nabla^2 n(\mathbf{r}) - \dfrac{A}{4n(\mathbf{r})} \left( \nabla n(\mathbf{r}) \right)^2\] <ul> <li>\(A = \dfrac{\hbar^2}{2m}\): Constant involving Planck’s constant \(\hbar\) and electron mass \(m\).</li> <li>The terms represent: <ul> <li><strong>First Term</strong>: Kinetic energy density of the non-interacting Kohn-Sham system.</li> <li><strong>Second Term</strong>: “Correlation correction.”</li> <li><strong>Third Term</strong>: Kinetic energy density of an ideal Bose gas at the same density.</li> </ul> </li> </ul> <p>The ELF is then calculated as:</p> \[\text{ELF}(\mathbf{r}) = \dfrac{1}{1 + \left( \dfrac{ D(\mathbf{r}) }{ D_0(\mathbf{r}) } \right)^2}\] <p>In the \(\texttt{VASP}\) source code, \(D = T + T_{corr.} - T_{bos.}\) could be found, which is the same thing.</p> <p>The numerator in the localization index now looks a bit different here, and the first guess should be that this of course looks like this because the normal expression has been broken down into direct, cross and divergence terms - and one would be correct!</p> <p>I still find it a tiny bit cathartic to show this explicitly (doing my part against entropy).</p> <h4 id="reconciling-the-expressions"><strong>Reconciling the Expressions</strong></h4> <h5 id="step-1-relate-the-first-term-to-total-kinetic-energy-density"><strong>Step 1: Relate the First Term to Total Kinetic Energy Density</strong></h5> <p>The first term in the CASTEP/VASP expression:</p> \[-2A \sum_i \psi_i^*(\mathbf{r}) \nabla^2 \psi_i(\mathbf{r})\] <p>Using the identity:</p> \[\psi_i^*(\mathbf{r}) \nabla^2 \psi_i(\mathbf{r}) = \nabla \cdot \left( \psi_i^*(\mathbf{r}) \nabla \psi_i(\mathbf{r}) \right) - |\nabla \psi_i(\mathbf{r})|^2\] <p>Substitute back:</p> \[-2A \sum_i \psi_i^*(\mathbf{r}) \nabla^2 \psi_i(\mathbf{r}) = 2A \sum_i |\nabla \psi_i(\mathbf{r})|^2 - 2A \sum_i \nabla \cdot \left( \psi_i^*(\mathbf{r}) \nabla \psi_i(\mathbf{r}) \right)\] <p>Note that the first term on the right-hand-side is twice the total kinetic energy density.</p> \[2 t(\mathbf{r}) = 2A \sum_i |\nabla \psi_i(\mathbf{r})|^2\] <h5 id="step-2-relate-the-second-and-third-terms-to-von-weizsäcker-kinetic-energy-density"><strong>Step 2: Relate the Second and Third Terms to von Weizsäcker Kinetic Energy Density</strong></h5> <p>The second term:</p> \[\dfrac{A}{2} \nabla^2 n(\mathbf{r}) = A \nabla \cdot \left( \dfrac{1}{2} \nabla n(\mathbf{r}) \right)\] <p>The third term:</p> \[- \dfrac{A}{4n(\mathbf{r})} \left( \nabla n(\mathbf{r}) \right)^2 = -2 t_W(\mathbf{r})\] <p>since:</p> \[t_W(\mathbf{r}) = \dfrac{1}{8} \dfrac{|\nabla n(\mathbf{r})|^2}{n(\mathbf{r})} = \dfrac{A}{4n(\mathbf{r})} |\nabla n(\mathbf{r})|^2\] <h5 id="step-3-combine-terms"><strong>Step 3: Combine Terms</strong></h5> <p>The total expression becomes:</p> \[D(\mathbf{r}) = 2 t(\mathbf{r}) - 2 t_W(\mathbf{r}) - 2A \sum_i \nabla \cdot \left( \psi_i^*(\mathbf{r}) \nabla \psi_i(\mathbf{r}) \right) + A \nabla \cdot \left( \dfrac{1}{2} \nabla n(\mathbf{r}) \right)\] <p>Group divergence terms:</p> \[D(\mathbf{r}) = 2 \left[ t(\mathbf{r}) - t_W(\mathbf{r}) \right] + \text{Divergence Terms}\] <p>Thus, we see that:</p> \[D(\mathbf{r}) = 2 t_P(\mathbf{r}) + \text{Divergence Terms}\] <h4 id="equivalence"><strong>Equivalence</strong></h4> <ul> <li>The CASTEP/VASP expression for \(D(\mathbf{r})\) essentially represents twice the Pauli kinetic energy density \(2 t_P(\mathbf{r})\), up to divergence terms.</li> <li>The divergence terms may cancel out or integrate to zero under appropriate boundary conditions but can be significant locally.</li> </ul> <hr/> <h3 id="scalar-fields-with-wannier-functions">Scalar fields with Wannier functions</h3> <p>The first step would be to recognize that we’re working with <em>Maximally localized</em> wannier functions. As as result, the phase is consistent.</p> <p>To that end, the solution should be simple.</p> <p>Given a scalar field \(w_n(r)\):</p> \[n(\mathbf{r}) = \sum_n^{\text{occ}} |\tilde{w}_n(\mathbf{r})|^2\] <p>And, calculate the kinetic energy density terms in the same way.</p> <p>Note that, at the end, we need \(D_h(r)\) and \(D(r) = \tau - \tau_w(r)\).</p> <hr/> <h3 id="density-and-density-gradient-from-w_nr">Density and density-gradient from \(w_n(r)\)</h3> <p>In terms of implementation, the electron density and its gradient can be constructed as:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="sh">"""</span><span class="s">Process the wannier function</span><span class="sh">"""</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wf</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">wannier_data</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="sh">"</span><span class="s">Processing Wannier function </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">wannier_data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">smooth_sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">wf</span> <span class="o">=</span> <span class="nf">gaussian_filter</span><span class="p">(</span><span class="n">wf</span><span class="p">,</span> <span class="n">smooth_sigma</span><span class="p">)</span>

    <span class="c1"># No normalization - Wannier functions should already be normalized
</span>
    <span class="c1"># Accumulate density (e/Å³)
</span>    <span class="n">density</span> <span class="o">+=</span> <span class="n">wf</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># Calculate gradients (Å^-4)
</span>    <span class="n">grad_wf</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_gradient</span><span class="p">(</span><span class="n">wf</span><span class="p">)</span>

    <span class="c1"># Accumulate kinetic energy density (eV/Å³)
</span>    <span class="c1"># Using same prefactor as VASP for consistency
</span>    <span class="n">tau</span> <span class="o">+=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">grad_wf</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Accumulate density gradient (e/Å⁴)
</span>    <span class="n">grad_density</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">wf</span><span class="p">[...,</span> <span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">grad_wf</span>

<span class="sh">"""</span><span class="s">Double density for non-spin-polarized system</span><span class="sh">"""</span>

<span class="n">density</span> <span class="o">*=</span> <span class="mf">2.0</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="symmetrization-of-scalar-fields">Symmetrization of scalar fields</h3> <p><strong>Strong</strong> emphasis needs to be laid on the importance of symmetrization of the charge density and kinetic energy scalar fields derived from wannier functions. Since the wannier functions are not <strong>symmetry-adapted</strong>, but <strong>maximally-localized</strong>, it matters quite a bit.</p> <blockquote class="block-tip"> <p><strong>Hint:</strong> Try to disable symmetrization in the code.</p> <p>See the <code class="language-plaintext highlighter-rouge">symmetrize_field()</code> method.</p> <p>Or, relax the constraints from <code class="language-plaintext highlighter-rouge">1e-5</code> to say, <code class="language-plaintext highlighter-rouge">1e-1</code>.</p> <p>And, see what happens!</p> </blockquote> <p>The following symmetrizations are therefore essential.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="sh">"""</span><span class="s">Symmetrize fields</span><span class="sh">"""</span>

<span class="n">density</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">symmetrize_field</span><span class="p">(</span><span class="n">density</span><span class="p">,</span> <span class="sh">"</span><span class="s">density</span><span class="sh">"</span><span class="p">)</span>
<span class="n">tau</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">symmetrize_field</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="sh">"</span><span class="s">kinetic energy density</span><span class="sh">"</span><span class="p">)</span>
<span class="n">grad_density</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">symmetrize_field</span><span class="p">(</span><span class="n">grad_density</span><span class="p">,</span> <span class="sh">"</span><span class="s">density gradient</span><span class="sh">"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>Here is the symmetrization utility, which can do this both in real and reciprocal space. <code class="language-plaintext highlighter-rouge">spglib</code> is used for detecting the lattice symmetry. It should be obvious that unless one has really dense 3D-scalar fields, accurate symmetrization in real space would be a bad idea.</p> <p>Symmetrization method based on argument; default is <code class="language-plaintext highlighter-rouge">reciprocal</code>.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">symmetrize_field</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Symmetrize a field according to crystal symmetry.
    Uses either real space or reciprocal space symmetrization based on initialization.

    Args:
        field: Scalar field with shape (nx, ny, nz) or vector field with shape (nx, ny, nz, 3)
        field_name: Name of field for logging

    Returns:
        symmetrized_field: Field with same shape as input but symmetrized
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">symmetrization_method</span> <span class="o">==</span> <span class="n">SymmetrizationMethod</span><span class="p">.</span><span class="n">RECIPROCAL</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_reciprocal_symmetrize</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">field_name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_real_symmetrize</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">field_name</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>If we select real space symmetrization:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">_real_symmetrize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Traditional symmetrization using averaging of symmetry-equivalent points in real space.
    </span><span class="sh">"""</span>
    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Starting real-space symmetrization of </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Store original field for validation
</span>    <span class="n">original_field</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>

    <span class="c1"># Get the shape and dimensions
</span>    <span class="n">field_shape</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">spatial_dims</span> <span class="o">=</span> <span class="n">field_shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">component_dims</span> <span class="o">=</span> <span class="n">field_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>  <span class="c1"># Empty for scalar field, (3,) for vector
</span>    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">spatial_dims</span>
    <span class="n">n_ops</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">)</span>

    <span class="c1"># Create fractional grid coordinates
</span>    <span class="n">grid_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">indices</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">T</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>

    <span class="c1"># Initialize array to accumulate field values
</span>    <span class="n">num_points</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid_points</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">component_dims</span><span class="p">:</span>
        <span class="n">sym_field_values</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">num_points</span><span class="p">,</span> <span class="n">n_ops</span><span class="p">)</span> <span class="o">+</span> <span class="n">component_dims</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sym_field_values</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">num_points</span><span class="p">,</span> <span class="n">n_ops</span><span class="p">))</span>

    <span class="c1"># Grid for interpolation
</span>    <span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">nz</span><span class="p">))</span>

    <span class="c1"># Reshape field for interpolation
</span>    <span class="n">field_reshaped</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">spatial_dims</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

    <span class="c1"># Apply symmetry operations
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">translations</span><span class="p">)):</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n_ops</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Processing symmetry operation </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">n_ops</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

        <span class="c1"># Apply rotation and translation to fractional coordinates
</span>        <span class="n">transformed_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid_points</span> <span class="o">@</span> <span class="n">rot</span><span class="p">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">trans</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.0</span>

        <span class="c1"># Convert fractional coordinates to grid indices
</span>        <span class="n">transformed_indices</span> <span class="o">=</span> <span class="n">transformed_coords</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>

        <span class="c1"># Ensure indices are within the grid
</span>        <span class="n">transformed_indices</span> <span class="o">%=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>

        <span class="c1"># Interpolate field values at transformed positions
</span>        <span class="n">field_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">field_reshaped</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nf">interpn</span><span class="p">(</span>
                <span class="n">grid</span><span class="p">,</span>
                <span class="n">field_reshaped</span><span class="p">[...,</span> <span class="n">comp</span><span class="p">],</span>
                <span class="n">transformed_indices</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="sh">"</span><span class="s">linear</span><span class="sh">"</span><span class="p">,</span>
                <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">field_values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># Stack component values
</span>        <span class="n">field_values</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span><span class="n">field_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># If scalar field, squeeze the last dimension
</span>        <span class="k">if</span> <span class="n">field_values</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">field_values</span> <span class="o">=</span> <span class="n">field_values</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">sym_field_values</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">...]</span> <span class="o">=</span> <span class="n">field_values</span>

    <span class="c1"># Average over symmetry operations
</span>    <span class="n">sym_field</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">sym_field_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Reshape symmetrized field back to original shape
</span>    <span class="n">sym_field</span> <span class="o">=</span> <span class="n">sym_field</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">field_shape</span><span class="p">)</span>

    <span class="c1"># Validate the symmetrized field
</span>    <span class="n">self</span><span class="p">.</span><span class="nf">validate_field_properties</span><span class="p">(</span><span class="n">sym_field</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">original_field</span><span class="p">)</span>

    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Completed real-space symmetrization of </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sym_field</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>If we select reciprocal space symmetrization:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">_reciprocal_symmetrize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Symmetrization in reciprocal space, similar to VASP</span><span class="sh">'</span><span class="s">s approach.
    </span><span class="sh">"""</span>
    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Starting reciprocal-space symmetrization of </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Store original field for validation
</span>    <span class="n">original_field</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>

    <span class="c1"># Transform to reciprocal space
</span>    <span class="n">field_reciprocal</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_to_reciprocal_space</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>

    <span class="c1"># Get reciprocal lattice vectors
</span>    <span class="n">recip_vecs</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get_reciprocal_vectors</span><span class="p">()</span>

    <span class="c1"># Get grid dimensions
</span>    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># Create reciprocal space grid
</span>    <span class="n">kx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">fftfreq</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="o">*</span> <span class="n">nx</span>  <span class="c1"># Scaled to match grid points
</span>    <span class="n">ky</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">fftfreq</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="o">*</span> <span class="n">ny</span>
    <span class="n">kz</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">fftfreq</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span> <span class="o">*</span> <span class="n">nz</span>

    <span class="c1"># Create meshgrid of k-points
</span>    <span class="n">kgrid</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">meshgrid</span><span class="p">(</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">kz</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="sh">"</span><span class="s">ij</span><span class="sh">"</span><span class="p">))</span>

    <span class="c1"># Initialize symmetrized field in reciprocal space
</span>    <span class="n">sym_field_reciprocal</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">field_reciprocal</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">field_reciprocal</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Apply symmetry operations in reciprocal space
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">translations</span><span class="p">)):</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Processing symmetry operation </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span>
            <span class="p">)</span>

        <span class="c1"># Rotate k-points
</span>        <span class="n">rot_kgrid</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">einsum</span><span class="p">(</span><span class="sh">"</span><span class="s">ij,jpqr-&gt;ipqr</span><span class="sh">"</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">)</span>

        <span class="c1"># Find corresponding indices in the FFT grid
</span>        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">rot_kgrid</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Apply periodic boundary conditions
</span>        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">%</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])[:,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>

        <span class="c1"># Compute phase factors from translations
</span>        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span>
            <span class="o">-</span><span class="mf">2j</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">trans</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">kgrid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Accumulate symmetrized components
</span>        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">iz</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">],</span>
                        <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">],</span>
                        <span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">sym_field_reciprocal</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">field_reciprocal</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">phase</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>

    <span class="c1"># Average by weights
</span>    <span class="n">mask</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">sym_field_reciprocal</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/=</span> <span class="n">weights</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

    <span class="c1"># Transform back to real space
</span>    <span class="n">sym_field</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_to_real_space</span><span class="p">(</span><span class="n">sym_field_reciprocal</span><span class="p">)</span>

    <span class="c1"># Ensure result is real
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">sym_field</span><span class="p">.</span><span class="n">imag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">warning</span><span class="p">(</span><span class="sh">"</span><span class="s">Symmetrized field has non-zero imaginary components</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">sym_field</span> <span class="o">=</span> <span class="n">sym_field</span><span class="p">.</span><span class="n">real</span>

    <span class="c1"># Validate the symmetrized field
</span>    <span class="n">self</span><span class="p">.</span><span class="nf">validate_field_properties</span><span class="p">(</span><span class="n">sym_field</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">original_field</span><span class="p">)</span>

    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Completed reciprocal-space symmetrization of </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sym_field</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>It should be made sure that the integral quantities are conserved before and after symmetrization, in addition to whether the scalar field obey ,symmetrization in different regions: <code class="language-plaintext highlighter-rouge">core</code>, <code class="language-plaintext highlighter-rouge">bonding</code>, <code class="language-plaintext highlighter-rouge">interstitial</code>, because even if the scalar field is sampled uniformly, the constituing wavefunctions/wannier-functions are most definitely not.</p> <p>So,</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="sh">"""</span><span class="s">Validate symmetry with spatial analysis</span><span class="sh">"""</span>

<span class="n">self</span><span class="p">.</span><span class="nf">validate_symmetry</span><span class="p">(</span><span class="n">density</span><span class="p">,</span> <span class="sh">"</span><span class="s">density</span><span class="sh">"</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">validate_symmetry</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="sh">"</span><span class="s">kinetic energy density</span><span class="sh">"</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">validate_symmetry</span><span class="p">(</span><span class="n">grad_density</span><span class="p">,</span> <span class="sh">"</span><span class="s">density gradient</span><span class="sh">"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>which calls upon the functions that validate symmetry and field properties</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">validate_symmetry</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Check if field obeys crystal symmetry, with spatial analysis relative to atomic positions.
    </span><span class="sh">"""</span>
    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Validating symmetry of </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Get field shape and dimensions
</span>    <span class="n">field_shape</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">spatial_dims</span> <span class="o">=</span> <span class="n">field_shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">spatial_dims</span>

    <span class="c1"># Create fractional grid coordinates
</span>    <span class="n">grid_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">indices</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">T</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>

    <span class="c1"># Sample subset of points for validation
</span>    <span class="n">num_points</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid_points</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">num_points</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">sampled_points</span> <span class="o">=</span> <span class="n">grid_points</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

    <span class="c1"># For scalar or vector fields, reshape as needed
</span>    <span class="n">field_reshaped</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">spatial_dims</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

    <span class="c1"># Grid for interpolation
</span>    <span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">nz</span><span class="p">))</span>

    <span class="c1"># Track violations by region
</span>    <span class="n">violations</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sh">"</span><span class="s">core</span><span class="sh">"</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># Within 1Å of nuclei
</span>        <span class="sh">"</span><span class="s">bonding</span><span class="sh">"</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># 1-2Å from nuclei
</span>        <span class="sh">"</span><span class="s">interstitial</span><span class="sh">"</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># &gt;2Å from nuclei
</span>    <span class="p">}</span>
    <span class="n">max_violation</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># For each sampled point, check symmetry
</span>    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">sampled_points</span><span class="p">):</span>
        <span class="c1"># Calculate distance to nearest atom
</span>        <span class="n">dist_to_atom</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_compute_distance_to_atoms</span><span class="p">(</span>
            <span class="n">point</span> <span class="o">*</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">],</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Check symmetry violation
</span>        <span class="n">field_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rot</span><span class="p">,</span> <span class="n">trans</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">translations</span><span class="p">):</span>
            <span class="n">transformed_point</span> <span class="o">=</span> <span class="p">(</span><span class="n">rot</span> <span class="o">@</span> <span class="n">point</span> <span class="o">+</span> <span class="n">trans</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.0</span>
            <span class="n">transformed_indices</span> <span class="o">=</span> <span class="n">transformed_point</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>
            <span class="n">transformed_indices</span> <span class="o">%=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>

            <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">field_reshaped</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nf">interpn</span><span class="p">(</span>
                    <span class="n">grid</span><span class="p">,</span>
                    <span class="n">field_reshaped</span><span class="p">[...,</span> <span class="n">comp</span><span class="p">],</span>
                    <span class="n">transformed_indices</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                    <span class="n">method</span><span class="o">=</span><span class="sh">"</span><span class="s">linear</span><span class="sh">"</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">field_values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">field_values</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">field_values</span><span class="p">)</span>
        <span class="n">max_diff</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">ptp</span><span class="p">(</span><span class="n">field_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">max_violation</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_violation</span><span class="p">,</span> <span class="n">max_diff</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <p><strong>AND</strong> validating the fields were symmetrized correctly</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">validate_field_properties</span><span class="p">(</span>
    <span class="n">self</span><span class="p">,</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">original_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Validate physical properties of a field.
    </span><span class="sh">"""</span>
    <span class="c1"># Check for NaN or infinite values
</span>    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="p">.</span><span class="nf">isfinite</span><span class="p">(</span><span class="n">field</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s"> contains NaN or infinite values</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Add unit-aware validation
</span>    <span class="k">if</span> <span class="n">field_name</span> <span class="o">==</span> <span class="sh">"</span><span class="s">density</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="n">field</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Negative values found in </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s"> range: [</span><span class="si">{</span><span class="n">field</span><span class="p">.</span><span class="nf">min</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">e</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">field</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">e</span><span class="si">}</span><span class="s">] e/Å³</span><span class="sh">"</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">field_name</span> <span class="o">==</span> <span class="sh">"</span><span class="s">kinetic energy density</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="n">field</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Negative values found in </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s"> range: [</span><span class="si">{</span><span class="n">field</span><span class="p">.</span><span class="nf">min</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">e</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">field</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">e</span><span class="si">}</span><span class="s">] eV/Å³</span><span class="sh">"</span>
        <span class="p">)</span>

    <span class="c1"># Check total integral conservation
</span>    <span class="k">if</span> <span class="n">original_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">det</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">atoms</span><span class="p">.</span><span class="n">cell</span><span class="p">))</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">dV</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">nz</span><span class="p">)</span>

        <span class="n">total_orig</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">original_field</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV</span>
        <span class="n">total_new</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV</span>

        <span class="n">relative_diff</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nf">abs</span><span class="p">(</span><span class="n">total_orig</span> <span class="o">-</span> <span class="n">total_new</span><span class="p">)</span> <span class="o">/</span> <span class="nf">abs</span><span class="p">(</span><span class="n">total_orig</span><span class="p">)</span>
            <span class="k">if</span> <span class="nf">abs</span><span class="p">(</span><span class="n">total_orig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-10</span>
            <span class="k">else</span> <span class="mf">0.0</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">relative_diff</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Total </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s"> not conserved after symmetrization. </span><span class="sh">"</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Relative difference: </span><span class="si">{</span><span class="n">relative_diff</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Total </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s"> conserved after symmetrization. </span><span class="sh">"</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Relative difference: </span><span class="si">{</span><span class="n">relative_diff</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span>
            <span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="calculating-mathrmelfr">Calculating \(\mathrm{ELF(r)}\)</h3> <p>Finally, calculating ELF, which is straightforward:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">Computing ELF...</span><span class="sh">"</span><span class="p">)</span>

<span class="sh">"""</span><span class="s">Apply density threshold to avoid numerical issues</span><span class="sh">"""</span>

<span class="n">density_threshold</span> <span class="o">=</span> <span class="mf">1e-6</span>  <span class="c1"># e/Å³
</span><span class="n">mask</span> <span class="o">=</span> <span class="n">density</span> <span class="o">&gt;</span> <span class="n">density_threshold</span>

<span class="sh">"""</span><span class="s">Calculate uniform electron gas kinetic energy density</span><span class="sh">"""</span>

<span class="sh">"""</span><span class="s">Following VASP</span><span class="sh">'</span><span class="s">s approach with same prefactors</span><span class="sh">"""</span>

<span class="n">D_h</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
<span class="n">D_h</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>

<span class="sh">"""</span><span class="s">Calculate Pauli kinetic energy term</span><span class="sh">"""</span>

<span class="n">grad_density_norm</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">grad_density</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">tau_w</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
<span class="n">tau_w</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_density_norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">8.0</span> <span class="o">*</span> <span class="n">density</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

<span class="sh">"""</span><span class="s">Calculate D = τ - τ_w</span><span class="sh">"""</span>

<span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">tau</span> <span class="o">-</span> <span class="n">tau_w</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="sh">"""</span><span class="s">Initialize ELF array (starting from 0.0, not 0.5)</span><span class="sh">"""</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>

<span class="sh">"""</span><span class="s">Compute dimensionless χ = D/D_h</span><span class="sh">"""</span>

<span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
<span class="n">chi</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="n">D_h</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

<span class="sh">"""</span><span class="s">Compute ELF</span><span class="sh">"""</span>

<span class="n">elf</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">chi</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>Using a <code class="language-plaintext highlighter-rouge">threshold</code>, masking values with <code class="language-plaintext highlighter-rouge">mask</code> seems to be important for stable values.</p> <hr/> <h3 id="writing-scalar-fields">Writing scalar fields</h3> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="n">self</span><span class="p">.</span><span class="nf">write_field_xsf</span><span class="p">(</span><span class="sh">"</span><span class="s">density.xsf</span><span class="sh">"</span><span class="p">,</span> <span class="n">density</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">write_field_xsf</span><span class="p">(</span><span class="sh">"</span><span class="s">tau.xsf</span><span class="sh">"</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">write_field_xsf</span><span class="p">(</span><span class="sh">"</span><span class="s">tau_w.xsf</span><span class="sh">"</span><span class="p">,</span> <span class="n">tau_w</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">write_field_xsf</span><span class="p">(</span><span class="sh">"</span><span class="s">D_h.xsf</span><span class="sh">"</span><span class="p">,</span> <span class="n">D_h</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">write_field_xsf</span><span class="p">(</span><span class="sh">"</span><span class="s">ELF.xsf</span><span class="sh">"</span><span class="p">,</span> <span class="n">elf</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>We make use of ASE’s write function:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">write_field_xsf</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Write a field to an XSF file for visualization.</span><span class="sh">"""</span>
    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Writing field to file: </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">write</span><span class="p">(</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">self</span><span class="p">.</span><span class="n">atoms</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="sh">"</span><span class="s">xsf</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
        <span class="n">origin</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span>
        <span class="n">span_vectors</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">span_vectors</span><span class="p">,</span>
    <span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="elf-obtained-from-w_nr">ELF obtained from \(w_n(r)\)</h3> <p>A good example is \(\mathrm{CeO_2}\) where Cerium is supposed to have +4 and not +3 formal oxidation state. So the \(ELF(r)\) field value near Cerium across all cross sections should be minimal.</p> <div class="l-page"> <iframe src="/assets/plotly/elf_plot.html" frameborder="0" scrolling="no" height="750px" width="100%" style="border: 1px dashed grey;"></iframe> </div> <blockquote class="block-info"> <p>If the image is empty, move the sliders at the bottom of the frame.</p> </blockquote> <hr/> <h3 id="conclusion"><strong>Conclusion</strong></h3> <p>Calculating the Electron Localization Function (ELF) using Wannier functions provides a localized perspective on electron localization, anc can potentially offer new insights into chemical bonding and electron pairing. Normalization, phase alignment, and inclusion of cross terms need to be carefully addressed. .. <em>Ongoing</em> …</p> <hr/> <h3 id="references"><strong>References</strong></h3> <ol> <li>Becke, A. D., &amp; Edgecombe, K. E. (1990). A simple measure of electron localization in atomic and molecular systems. <em>The Journal of Chemical Physics</em>, 92(9), 5397–5403.</li> <li>Silvi, B., &amp; Savin, A. (1994). Classification of chemical bonds based on topological analysis of electron localization functions. <em>Nature</em>, 371(6499), 683–686.</li> <li>Kohn, W., &amp; Sham, L. J. (1965). Self-consistent equations including exchange and correlation effects. <em>Physical Review</em>, 140(4A), A1133.</li> <li>Marzari, N., Mostofi, A. A., Yates, J. R., Souza, I., &amp; Vanderbilt, D. (2012). Maximally localized Wannier functions: Theory and applications. <em>Reviews of Modern Physics</em>, 84(4), 1419–1475.</li> <li>Bader, R. F. W. (1990). <em>Atoms in Molecules: A Quantum Theory</em>. Oxford University Press.</li> <li>Yang, W., &amp; Parr, R. G. (1985). Hardness, softness, and the Fukui function in the electronic theory of metals and catalysis. <em>Proceedings of the National Academy of Sciences</em>, 82(20), 6723–6726.</li> <li>Silvi, B., &amp; Gatti, C. (2000). Electron localization function along a bond and atomic shell structure in solids. <em>The Journal of Physical Chemistry A</em>, 104(13), 2627–2635.</li> <li>Henkelman, G., Arnaldsson, A., &amp; Jónsson, H. (2006). A fast and robust algorithm for Bader decomposition of charge density. <em>Computational Materials Science</em>, 36(3), 354–360.</li> </ol>]]></content><author><name></name></author><category term="worklog"/><category term="wannier"/><category term="DFT"/><category term="ELF"/><category term="physics"/><summary type="html"><![CDATA[A worklog implementing calculation of Electron Localization Function (ELF) with wannier functions.]]></summary></entry><entry><title type="html">[Stuff I read] Dark states of electrons in a quantum system with two pairs of sublattices</title><link href="https://utksi.github.io/blog/2024/dark_states/" rel="alternate" type="text/html" title="[Stuff I read] Dark states of electrons in a quantum system with two pairs of sublattices"/><published>2024-09-13T12:59:44+00:00</published><updated>2024-09-13T12:59:44+00:00</updated><id>https://utksi.github.io/blog/2024/dark_states</id><content type="html" xml:base="https://utksi.github.io/blog/2024/dark_states/"><![CDATA[<ul> <li>A slightly different way of looking at dark bands in the BZ. See <a href="https://doi.org/10.1038/s41567-024-02586-x">Chung et al</a></li> </ul> <p>This review discusses the discovery of <strong>condensed-matter dark states</strong> in the material <strong>Palladium Diselenide (PdSe₂)</strong>, where entire bands of quantum states in the Brillouin zone remain undetectable via angle-resolved photoemission spectroscopy (ARPES). The dark states arise due to interference effects between sublattices, a novel feature in quantum materials.</p> <hr/> <h2 id="1-introduction-to-dark-states">1. Introduction to Dark States</h2> <p>In quantum mechanics, a <strong>dark state</strong> refers to a state that cannot absorb or emit photons and is thus undetectable through typical spectroscopic methods. These states are typically well-known in atomic and molecular systems where they arise due to <strong>quantum interference</strong> or <strong>conservation of angular momentum</strong>.</p> <p>In the condensed matter context, dark states have been less explored, especially when caused by interference between <strong>sublattices</strong>. This paper expands the concept to solid-state systems, where dark states emerge due to destructive interference within the crystal’s sublattices. These states remain hidden from ARPES measurements because their transition matrix elements vanish.</p> <h3 id="key-definitions-1">Key Definitions (1)</h3> <ul> <li><strong>Dark State</strong>: A quantum state that does not interact with light and is therefore undetectable by traditional spectroscopic methods.</li> <li><strong>Quantum Interference</strong>: The phenomenon where the probability amplitudes of quantum states add or cancel out, affecting the visibility of quantum transitions.</li> </ul> <hr/> <h2 id="2-crystal-structure-and-sublattice-symmetry">2. Crystal Structure and Sublattice Symmetry</h2> <p>PdSe₂ is chosen for its crystal structure, which consists of two pairs of <strong>sublattices</strong> labeled A, B, C, and D. These sublattices are related by <strong>glide-mirror symmetries</strong>, which leads to specific <strong>quantum phases</strong> that control the interference patterns of electronic wavefunctions in the Brillouin zone.</p> <p>Mathematically, the electronic structure of PdSe₂ is described using the <strong>tight-binding Hamiltonian</strong> model. The dominant states arise from <strong>Pd 4d orbitals</strong>, and the relative phases \(\varphi_{AB}, \varphi_{AC}, \varphi_{AD}\) between sublattices dictate whether the interference is constructive or destructive.</p> \[H_{PdSe_2} = \begin{pmatrix} f_{AA} &amp; f_{AB} &amp; f_{AC} &amp; f_{AD} \\ f_{AB} &amp; f_{AA} &amp; f_{AC} &amp; f_{AD} \\ f_{AC} &amp; f_{AD} &amp; f_{AA} &amp; f_{AB} \\ f_{AD} &amp; f_{AC} &amp; f_{AB} &amp; f_{AA} \end{pmatrix}\] <p>The key discovery here is that PdSe₂ has a unique sublattice arrangement where <strong>multiple glide-mirror symmetries</strong> connect these sublattices, resulting in <strong>double destructive interference</strong> under certain conditions, leading to the appearance of <strong>dark states</strong>.</p> <h3 id="key-definitions-2">Key Definitions (2)</h3> <ul> <li><strong>Sublattice</strong>: A subset of atoms within a crystal lattice that repeats in a regular pattern.</li> <li><strong>Glide-Mirror Symmetry</strong>: A symmetry operation combining a reflection with a translation.</li> <li><strong>Tight-Binding Hamiltonian</strong>: A mathematical model used to describe the movement of electrons in a material by considering the hopping between atoms.</li> </ul> <hr/> <h2 id="3-angle-resolved-photoemission-spectroscopy-arpes-light-polarization-and-dark-states">3. Angle-Resolved Photoemission Spectroscopy (ARPES), Light Polarization, and Dark States</h2> <p>The experimental technique used in the paper, <strong>ARPES</strong>, allows researchers to probe the electronic band structure of a material. However, in PdSe₂, an entire band of electronic states in the Brillouin zone is <strong>invisible</strong> regardless of the photon energy or light polarization used. This is a clear indicator of <strong>dark states</strong> resulting from <strong>sublattice interference</strong>.</p> <p>The transition probability in ARPES is governed by <strong>Fermi’s Golden Rule</strong>:</p> \[M_k = \int \psi_f^* (\mathbf{A} \cdot \mathbf{p}) \psi_i \, dV\] <p>Where:</p> <ul> <li>\(\mathbf{A}\) is the electromagnetic vector potential.</li> <li>\(\mathbf{p}\) is the momentum operator.</li> <li>\(\psi_i\) and \(\psi_f\) are the initial and final electronic states.</li> </ul> <p>The critical point in PdSe₂ is that the <strong>interference between sublattices</strong> can lead to <strong>destructive interference</strong> when certain relative quantum phases \(\varphi_{AB}, \varphi_{AC}, \varphi_{AD}\) cancel out the matrix elements \(M_k\). This makes some states completely <strong>undetectable by ARPES</strong>.</p> <p>The experimental data shows that with <strong>p-polarized light</strong>, only one of the <strong>nine cuboidal Brillouin zones</strong> exhibits detectable valence bands (centered at Γ₆). However, when using <strong>s-polarized light</strong>, even this valence band disappears, as shown in the data taken under identical experimental conditions.</p> <p>In summary:</p> <ul> <li>With <strong>p-polarized light</strong>, constructive interference allows detection of the 000 state.</li> <li>With <strong>s-polarized light</strong>, all pseudospin states vanish due to destructive interference.</li> <li>Bands centered at \(\Gamma_{106}, \Gamma_{101}, \Gamma_{016}\) in the kx and ky directions are <strong>not observed</strong> regardless of the polarization.</li> </ul> <p>This clearly indicates the existence of <strong>dark states</strong> in PdSe₂, which are <strong>undetectable</strong> at any photon energy or light polarization due to <strong>double destructive interference</strong> in these sublattices.</p> <h3 id="key-definitions-3">Key Definitions (3)</h3> <ul> <li><strong>ARPES</strong>: A technique used to observe the energy and momentum distribution of electrons in a material, providing insights into its electronic structure.</li> <li><strong>Fermi’s Golden Rule</strong>: A formula that calculates the transition probability per unit time for a quantum system interacting with an external perturbation.</li> <li><strong>p-polarized light</strong>: Light in which the electric field oscillates parallel to the plane of incidence.</li> <li><strong>s-polarized light</strong>: Light in which the electric field oscillates perpendicular to the plane of incidence.</li> </ul> <hr/> <h2 id="4-phase-polarization-and-quantum-states-in-the-brillouin-zone">4. Phase Polarization and Quantum States in the Brillouin Zone</h2> <p>A major finding in this paper is the identification of <strong>phase polarization</strong> in the Brillouin zone of PdSe₂. The electronic wavefunctions in PdSe₂ are fully polarized to one of four possible states: <strong>000, 0ππ, π0π, ππ0</strong>, depending on the relative quantum phases \(\varphi_{AB}, \varphi_{AC}, \varphi_{AD}\).</p> <ul> <li>The <strong>000 state</strong> (blue pseudospin) is <strong>visible</strong> in ARPES under <strong>p-polarized light</strong>, because constructive interference ensures a non-zero matrix element.</li> <li>The other states, <strong>0ππ, π0π, and ππ0</strong> (red, yellow, and green pseudospins), are <strong>dark states</strong> because two of the three quantum phases are \(\pi\), leading to <strong>double destructive interference</strong>. These states are completely undetectable by ARPES under <strong>any light polarization</strong>.</li> </ul> <p>The phase polarization forms a <strong>checkerboard pattern</strong> in momentum space, where each region of the Brillouin zone is polarized to one of these four states. The <strong>dark states</strong> correspond to areas where double destructive interference occurs, making the electronic states invisible in ARPES measurements.</p> <h3 id="key-definitions-4">Key Definitions (4)</h3> <ul> <li><strong>Pseudospin</strong>: An abstract concept used to describe two-level quantum systems, often associated with sublattices or quantum states.</li> <li><strong>Brillouin Zone</strong>: The fundamental region of reciprocal space in a crystal, within which the electronic wavefunctions are defined.</li> </ul> <hr/> <h2 id="5-generalization-to-other-materials">5. Generalization to Other Materials</h2> <p>The paper also generalizes the findings on dark states to other material systems with similar sublattice structures. This includes:</p> <ul> <li><strong>Cuprates</strong>: In high-temperature superconductors such as <strong>Bi2201</strong>, shadow bands have been observed in ARPES that cannot be explained by typical band theory. The paper demonstrates that these shadow bands are <strong>dark states</strong>, undetectable due to sublattice interference. <ul> <li>For cuprates, the two nearly degenerate Fermi surfaces (FS1 and FS2) show that segments of the Fermi surface polarized to <strong>000 states</strong> are visible in ARPES with <strong>p-polarized light</strong>, while segments polarized to <strong>0ππ states</strong> are visible with <strong>s-polarized light</strong>.</li> <li>However, parts of the Fermi surface polarized to <strong>π0π</strong> and <strong>ππ0</strong> remain undetectable due to dark states.</li> </ul> </li> <li><strong>Lead Halide Perovskites</strong>: In <strong>CsPbBr₃</strong>, ARPES measurements show that two distinct valence bands (VB1 and VB2) are observed depending on the photon energy used (kz = \(\Gamma_7\) for VB1, kz = \(\Gamma_8\) for VB2). However, only specific bands appear under <strong>p-polarized light</strong>, and both bands vanish under <strong>s-polarized light</strong>. This behavior is explained as a result of <strong>dark states</strong> in the perovskite’s sublattice structure.</li> </ul> <p>These findings demonstrate that the phenomenon of <strong>dark states</strong> is not limited to PdSe₂ but is a <strong>universal feature</strong> in materials with two pairs of sublattices connected by <strong>glide-mirror symmetries</strong>.</p> <h3 id="key-definitions-5">Key Definitions (5)</h3> <ul> <li><strong>Shadow Bands</strong>: Bands in the ARPES data of cuprates that appear with lower intensity or are completely undetectable due to their sublattice interference.</li> <li><strong>Band Folding</strong>: A phenomenon in ARPES where multiple bands appear due to the periodicity of the crystal lattice, often related to structural distortions or superlattice formations.</li> </ul> <hr/> <h2 id="6-novel-contributions-and-impact-of-the-paper">6. Novel Contributions and Impact of the Paper</h2> <p>The paper makes several important novel contributions to the field of condensed matter physics:</p> <ol> <li> <p><strong>Discovery of Condensed-Matter Dark States</strong>: This study is the first to report the observation of dark states in a solid-state material (PdSe₂). These dark states are completely undetectable in ARPES due to destructive interference between wavefunctions from different sublattices. This represents a new class of quantum states in condensed matter physics that had previously only been studied in atomic and molecular systems.</p> </li> <li> <p><strong>Mechanism of Sublattice Interference</strong>: The authors introduce a rigorous theoretical framework that explains how the interference between sublattices, connected by <strong>glide-mirror symmetries</strong>, leads to the emergence of dark states. The framework is supported by first-principles calculations and the <strong>tight-binding Hamiltonian</strong> model, which accurately describes the band structure and phase relationships in PdSe₂.</p> </li> <li> <p><strong>Generalization to Other Systems</strong>: The study extends the concept of dark states to other materials, such as <strong>cuprates</strong> and <strong>lead halide perovskites</strong>, providing a unified explanation for previously unexplained ARPES data in these systems. For example, the <strong>shadow bands</strong> in cuprates and the <strong>vanishing bands</strong> in perovskites can now be understood as the result of sublattice interference and dark states.</p> </li> <li> <p><strong>Light Polarization Effects</strong>: One of the most striking aspects of the paper is the detailed discussion of how <strong>light polarization</strong> affects the visibility of electronic states in ARPES. The authors show that:</p> <ul> <li><strong>p-polarized light</strong> can detect certain quantum states (e.g., the 000 state in PdSe₂).</li> <li><strong>s-polarized light</strong> renders all states invisible due to complete destructive interference. This effect has profound implications for future experimental studies using ARPES, as it highlights the need to carefully control light polarization to detect or suppress specific quantum states.</li> </ul> </li> </ol> <h3 id="why-this-paper-is-impressive">Why This Paper is Impressive</h3> <p>This paper is highly impressive for several reasons:</p> <ul> <li><strong>Novel Concept</strong>: The generalization of <strong>dark states</strong> to condensed matter systems is a significant breakthrough. It opens up a new avenue of research for understanding hidden quantum states in materials that were previously inaccessible to experimental probes like ARPES.</li> <li><strong>Comprehensive Approach</strong>: The combination of sophisticated experimental techniques (e.g., ARPES) with detailed theoretical modeling (tight-binding calculations and symmetry analysis) makes this paper a comprehensive and authoritative study on the topic.</li> <li><strong>Broad Implications</strong>: The findings are not limited to PdSe₂ but extend to a wide range of materials with sublattice structures. This could have far-reaching implications for the study of high-temperature superconductors, optoelectronic materials, and other quantum systems.</li> <li><strong>Resolution of Long-Standing Puzzles</strong>: By explaining phenomena such as the shadow bands in cuprates and the vanishing bands in perovskites, the paper resolves several long-standing puzzles in the field of condensed matter physics.</li> </ul> <p>In summary, the discovery of condensed-matter dark states, the detailed analysis of sublattice interference, and the generalization to other material systems make this paper a landmark contribution to the study of quantum materials.</p> <hr/> <h3 id="key-definitions-recap">Key Definitions (Recap)</h3> <ul> <li><strong>Dark State</strong>: A quantum state that does not interact with light, making it undetectable in spectroscopic experiments.</li> <li><strong>Sublattice Interference</strong>: The interaction between wavefunctions from different sublattices, leading to constructive or destructive interference.</li> <li><strong>p-polarized light</strong>: Light whose electric field oscillates parallel to the plane of incidence, often used to detect quantum states in ARPES.</li> <li><strong>s-polarized light</strong>: Light whose electric field oscillates perpendicular to the plane of incidence, which can cause destructive interference in certain quantum states.</li> <li><strong>Fermi’s Golden Rule</strong>: A quantum mechanical formula used to calculate the transition probability of electrons between states when interacting with light.</li> </ul>]]></content><author><name></name></author><category term="stuff-i-read"/><category term="physics"/><category term="spectroscopy"/><category term="materials-science"/><summary type="html"><![CDATA[A high-level summary of main ideas from Chung et al.]]></summary></entry><entry><title type="html">[Stuff I read] Phonon induced renormalization of exchange interactions in two-dimensional magnets</title><link href="https://utksi.github.io/blog/2024/renorm/" rel="alternate" type="text/html" title="[Stuff I read] Phonon induced renormalization of exchange interactions in two-dimensional magnets"/><published>2024-06-13T15:59:44+00:00</published><updated>2024-06-13T15:59:44+00:00</updated><id>https://utksi.github.io/blog/2024/renorm</id><content type="html" xml:base="https://utksi.github.io/blog/2024/renorm/"><![CDATA[<ul> <li>Via <a href="https://arxiv.org/abs/2406.05229">Badrtdinov, Katsnelson &amp; Rudenko</a></li> <li>I find this very interesting. There have been recent (relatively) works on introducing spin-lattice interaction in practical implementation(s) of ASD solvers [See the work from Anders Bergman and Anna Delin (2022-2023)], but renormalization is not taken care of in those things explicitly. To get a measure of how much the exchange interactions are affected as a function of temperature independent of explicit electron-phonon interactions, this could be interesting.</li> </ul> <h2 id="first-a-one-line-or-two-d-introduction-to-key-concepts">First, a one line (or two :D) introduction to key concepts</h2> <p><strong>Magnetism in 2D Materials</strong>:</p> <ul> <li><strong>2D Magnets</strong> are materials with magnetic properties confined to two dimensions, influenced significantly by quantum effects. They are promising for applications in spintronics, where electronic spins are used to store, process, and transfer information.</li> </ul> <p><strong>Heisenberg Model</strong>:</p> <ul> <li>Describes magnetic interactions through pairwise exchange interactions.</li> <li>The Hamiltonian: \(H_0 = \sum_{i &gt; j} J_{ij} \mathbf{S}_i \cdot \mathbf{S}_j\) where \(J_{ij}\) is the exchange interaction between spins \(\mathbf{S}_i\) and \(\mathbf{S}_j\).</li> </ul> <p><strong>Electron-Phonon Coupling</strong>:</p> <ul> <li>Refers to interactions between electrons and lattice vibrations (phonons).</li> <li>These interactions affect various electronic properties, including magnetic exchange interactions.</li> </ul> <p><strong>Green’s Functions and Self-Energy</strong>:</p> <ul> <li><strong>Green’s Functions</strong> \(G^{\sigma}_{ij}(i\omega_n)\): Describe electron propagation with spin \(\sigma\).</li> <li><strong>Self-Energy</strong> \(\Sigma^{\sigma}_k(i\omega_n)\): Represents interaction effects on electrons due to phonons and other electrons.</li> </ul> <h2 id="1-theory-and-model">1. Theory and Model</h2> <p>The paper extends the Heisenberg model to include electron-phonon interactions, recalculating the exchange interaction \(J_{ij}\) using the magnetic force theorem:</p> \[J_{ij} = 2 \text{Tr}_{\omega L} \left[ \Delta_i G^{\uparrow}_{ij}(i\omega_n) \Delta_j G^{\downarrow}_{ji}(i\omega_n) \right] S^{-2}\] <p>where:</p> <ul> <li>\(\Delta_i\) is the exchange splitting at lattice site \(i\).</li> <li>\(G^{\sigma}_{ij}(i\omega_n)\) is the spin-polarized electron propagator.</li> <li>\(\text{Tr}_{\omega L}\) denotes the trace over Matsubara frequencies \(i\omega_n\) and orbital indices \(L\).</li> </ul> <p>Incorporating electron-phonon interactions, the Green’s function is renormalized using the Dyson equation:</p> \[G^{-1}_k(i\omega_n) \rightarrow \tilde{G}^{-1}_k(i\omega_n) = G^{-1}_k(i\omega_n) - \Sigma_k(i\omega_n)\] <p>This leads to a renormalized exchange splitting:</p> \[\Delta \rightarrow \tilde{\Delta}_k(i\omega_n) = \Delta + \Sigma^{\uparrow}_k(i\omega_n) - \Sigma^{\downarrow}_k(i\omega_n)\] <p>where the self-energy \(\Sigma^{\sigma}_k(i\omega_n)\) is given by:</p> \[\Sigma^{\sigma}_k(i\omega_n) = -T \sum_{k' \nu m} G^{\sigma}_{k'}(i\omega_n - i\omega_m) |g^{\nu \sigma}_{kk'}|^2 D_{k-k'}(i\omega_n - i\omega_m)\] <p>Here, \(g^{\nu \sigma}_{kk'}\) is the electron-phonon coupling vertex, and \(D_q(i\omega_n)\) is the phonon propagator.</p> <p><strong>Context</strong>: This theoretical framework allows the authors to predict how the electron-phonon interactions influence the magnetic properties of 2D materials by renormalizing the exchange interactions between spins.</p> <h2 id="2-square-lattice-model">2. Square Lattice Model</h2> <p>To illustrate the effect, the authors use a square lattice model at half-filling with the Hamiltonian:</p> \[H = t \sum_{\langle ij \rangle \sigma} c^{\dagger}_{i\sigma} c_{j\sigma} + \frac{\Delta}{2} \sum_i (n^{\uparrow}_i - n^{\downarrow}_i) + \sum_q \omega_q b^{\dagger}_q b_q + \sum_{q, \langle ij \rangle \sigma} g_q (b^{\dagger}_q + b_{-q}) c^{\dagger}_{i\sigma} c_{j\sigma}\] <p>where:</p> <ul> <li>\(t\) is the nearest-neighbor hopping.</li> <li>\(\Delta\) is the on-site exchange splitting.</li> <li>\(\omega_q\) is the phonon frequency.</li> <li>\(g_q\) is the electron-phonon coupling constant.</li> </ul> <p>The self-energy in the high-temperature limit simplifies to:</p> \[\Sigma^{\sigma}_k(\omega, T) = 2\lambda \frac{k_BT}{N^{\sigma}_F} \sum_q G^{\sigma}_{k+q}(\omega)\] <p>where \(\lambda\) is the dimensionless electron-phonon coupling constant.</p> <p><strong>Context</strong>: The square lattice model serves as a simple yet effective system to understand the temperature dependence of exchange interactions due to electron-phonon coupling.</p> <h2 id="3-renormalization-of-exchange-interactions">3. Renormalization of Exchange Interactions</h2> <p>The main result shows that the exchange interaction is renormalized linearly with temperature due to electron-phonon coupling:</p> \[J(T) = J(0) - c\lambda T\] <p>where \(c\) is a renormalization constant.</p> <p><strong>Derivation</strong>:</p> <ul> <li>The linear temperature dependence arises from the self-energy correction, which modifies the exchange interaction strength \(J_{ij}\).</li> <li>The renormalization constant \(c\) is determined by the specific electronic structure of the material and the strength of the electron-phonon coupling.</li> </ul> <h2 id="4-application-to-mathrmfe_3gete_2">4. Application to \(\mathrm{Fe_3GeTe_2}\)</h2> <p>For the metallic 2D ferromagnet \(\mathrm{Fe_3GeTe_2}\), the authors use first-principles calculations to determine the electronic and phononic structures. The temperature dependence of the exchange interactions is calculated, showing a reduction of the Curie temperature by about 10% due to electron-phonon interactions.</p> <p><strong>First-Principles Calculation</strong>:</p> <ul> <li><strong>Density Functional Theory (DFT)</strong> is employed to calculate the electronic structure.</li> <li><strong>Density Functional Perturbation Theory (DFPT)</strong> is used for phonon calculations.</li> <li>The electronic structure in the vicinity of the Fermi level is parameterized using maximally localized Wannier functions.</li> </ul> <p><strong>Context</strong>: Wannierization is an invaluable tool for simply writing the hamiltonian in a local basis in the vicinity of the Fermi level, such a model is easier to solve exactly at lower (read: more rigorous) levels of theory as well, which is essential for evaluating the temperature-dependent exchange interactions.</p> <h2 id="5-spin-wave-renormalization">5. Spin-Wave Renormalization</h2> <p><strong>Spin-Wave Theory</strong>:</p> <ul> <li>Spin waves, or magnons, are collective excitations in a magnetically ordered system.</li> <li>The stability of magnetic order is influenced by spin-wave spectra, which can be calculated by diagonalizing the spin-wave Hamiltonian.</li> </ul> <p>The Heisenberg model with single-ion anisotropy (SIA) is used to describe the spin waves:</p> \[H = H_0 + A \sum_i (S^z_i)^2\] <p>where \(A\) is the anisotropy parameter.</p> <p><strong>Magnon Eigenvectors and Spectra</strong>:</p> <ul> <li>Magnon frequencies \(\Omega_{q \nu}\) are obtained by diagonalizing the spin-wave Hamiltonian:</li> </ul> \[H^{\text{SW}}_{\mu \nu}(q) = \left[ \delta_{\mu \nu} \left( 2A \Phi + \sum_{\chi} J_{\mu \chi}(0) \right) - J_{\mu \nu}(q) \right] \langle S^z \rangle\] <p>where:</p> <ul> <li>\(J_{\mu \nu}(q)\) are the Fourier transforms of the exchange interaction matrix.</li> <li>\(\Phi = 1 - \left( 1 - \langle S^2_z \rangle / 2 \right)\) is the Anderson-Callen decoupling factor for \(S = 1\).</li> </ul> <p>The magnon spectra exhibit optical and acoustic branches. Near the \(\Gamma\) point, the acoustic branch disperses quadratically:</p> \[\Omega_q \approx \Omega_0 + Dq^2\] <p>where \(D\) is the spin-stiffness constant and \(\Omega_0\) is the gap due to single-ion anisotropy.</p> <p><strong>Temperature-Dependent Magnetization</strong>:</p> <ul> <li>Magnetization \(\langle S^z \rangle\) is determined by spin-wave excitations, using the Tyablikov decoupling (RPA):</li> </ul> \[\langle (S^z_i)^n S^-_i S^+_i \rangle = \langle [S^+_i, (S^z_i)^n S^-_i] \rangle \sum_{q \nu} \langle b^{\dagger}_{q \nu} b_{q \nu} \rangle\] <p>where \(\langle b^{\dagger}_{q \nu} b_{q \nu} \rangle = [\exp(\Omega_{q \nu} / k_BT) - 1]^{-1}\) is the equilibrium magnon distribution.</p> <p>By solving these equations self-consistently, the renormalized exchange interactions \(J(T)\) are used to calculate the Curie temperature \(T_C\). The renormalized interactions lead to a reduced \(T_C\) compared to the non-renormalized case.</p> <p><strong>Context</strong>: The detailed calculation of spin-wave spectra and their temperature dependence provides insight into the stability of magnetic order and how it is influenced by electron-phonon interactions.</p> <h2 id="discussion">Discussion</h2> <p>The discussion highlights several key points:</p> <ol> <li><strong>Adiabatic vs. Antiadiabatic Electron-Phonon Coupling</strong>: <ul> <li>Most systems can be treated adiabatically, where phonon energies are much smaller than electron energies.</li> <li>For stronger renormalization effects, systems with narrow electron bands or high phonon energies relative to electron energies need to be considered.</li> </ul> </li> <li><strong>Out-of-Equilibrium Effects</strong>: <ul> <li>Non-equilibrium distributions, such as those induced by charge currents or laser fields, can enhance electron-phonon coupling.</li> <li>This can lead to significant changes in exchange interactions and magnetic properties.</li> </ul> </li> <li><strong>Anisotropic Magnetic Interactions</strong>: <ul> <li>The study focuses on isotropic exchange interactions, but anisotropic interactions, such as Dzyaloshinskii-Moriya interaction (DMI), can exhibit stronger renormalization effects.</li> </ul> </li> </ol> <p><strong>Conclusion</strong>: The study demonstrates that electron-phonon coupling significantly affects the magnetic properties of 2D metallic magnets by renormalizing the exchange interactions. This renormalization leads to a suppression of magnetic ordering temperatures and modifies the magnon spectra, which has implications for the design and application of 2D magnetic materials in technology.</p> <h3 id="one-or-two-d-line-mathematical-context">One (or two :D) line mathematical context</h3> <p><strong>Magnetic Force Theorem</strong>:</p> <ul> <li>The exchange interaction \(J_{ij}\) is derived from the magnetic force theorem, which involves calculating the energy cost of rotating spins \(\mathbf{S}_i\) and \(\mathbf{S}_j\).</li> <li>The exchange interaction is given by the integral over the Brillouin zone of the product of the spin-resolved Green’s functions and exchange splitting.</li> </ul> <p><strong>Dyson Equation</strong>:</p> <ul> <li>The renormalization of Green’s functions due to self-energy \(\Sigma_k(i\omega_n)\) is given by the Dyson equation.</li> <li>This renormalizes both the propagators and the exchange splitting.</li> </ul> <p><strong>Electron-Phonon Self-Energy</strong>:</p> <ul> <li>The self-energy \(\Sigma^{\sigma}_k(i\omega_n)\) represents the correction to the electron’s energy due to its interaction with phonons.</li> <li>The self-energy is calculated using second-order perturbation theory in the electron-phonon coupling.</li> </ul> <p><strong>Spin-Wave Theory</strong>:</p> <ul> <li>The spin-wave Hamiltonian is derived by expanding the Heisenberg Hamiltonian to second order in spin deviations.</li> <li>Diagonalizing the resulting Hamiltonian gives the magnon eigenvalues (frequencies) and eigenvectors.</li> </ul> <p><strong>Temperature-Dependent Magnetization</strong>:</p> <ul> <li>The magnetization \(\langle S^z \rangle\) is obtained using the Tyablikov decoupling method, which approximates the thermal averages of spin operators.</li> <li>The self-consistent solution of the magnetization equations provides the temperature dependence of \(\langle S^z \rangle\) and \(J(T)\).</li> </ul> <h3 id="conclusion">Conclusion</h3> <p>I haven’t really thought of more implications, not further than what the authors imply.</p>]]></content><author><name></name></author><category term="stuff-i-read"/><category term="physics"/><category term="magnetism"/><summary type="html"><![CDATA[A high-level summary of main ideas from Badrtdinov et al.]]></summary></entry><entry><title type="html">Cooperative Graph Neural Networks</title><link href="https://utksi.github.io/blog/2024/cognn/" rel="alternate" type="text/html" title="Cooperative Graph Neural Networks"/><published>2024-05-01T07:18:00+00:00</published><updated>2024-05-01T07:18:00+00:00</updated><id>https://utksi.github.io/blog/2024/cognn</id><content type="html" xml:base="https://utksi.github.io/blog/2024/cognn/"><![CDATA[<h2 id="cooperative-graph-neural-networks-co-gnns">Cooperative Graph Neural Networks (Co-GNNs)</h2> <ul> <li>Proposed by <a href="https://arxiv.org/abs/2310.01267">Finkelstein et al.</a></li> </ul> <h3 id="framework-overview"><strong>Framework Overview</strong></h3> <p>Co-GNNs introduce a novel, flexible message-passing mechanism where each node in the graph dynamically selects from the actions: <code class="language-plaintext highlighter-rouge">listen</code>, <code class="language-plaintext highlighter-rouge">broadcast</code>, <code class="language-plaintext highlighter-rouge">listen and broadcast</code>, or <code class="language-plaintext highlighter-rouge">isolate</code>. This is facilitated by two cooperating networks:</p> <ol> <li><strong>Action Network (\(\large{\pi}\))</strong>: Determines the optimal action for each node.</li> <li><strong>Environment Network (\(\large{\eta}\))</strong>: Updates the node states based on the chosen actions.</li> </ol> <h2 id="mathematical-formulation"><strong>Mathematical Formulation</strong></h2> <ol> <li><strong>Action Selection (Action Network π)</strong>: <ul> <li>For each node \(\large{v}\) , the action network predicts a probability distribution \(\large{p^{(\ell)}_v}\) over the actions {S, L, B, I} at layer \(\ell\) .</li> </ul> \[p^{(\ell)}_v = \pi \left( h^{(\ell)}_v, \{ h^{(\ell)}_u \mid u \in N_v \} \right)\] <ul> <li>Actions are sampled using the Straight-through Gumbel-softmax estimator.</li> </ul> </li> <li><strong>State Update (Environment Network η)</strong>: <ul> <li>The environment network updates the node states based on the selected actions.</li> </ul> \[h^{(\ell+1)}_v = \begin{cases} \eta^{(\ell)} \left( h^{(\ell)}_v, \{ \} \right) &amp; \text{if } a^{(\ell)}_v = \text{I or B} \\ \eta^{(\ell)} \left( h^{(\ell)}_v, \{ h^{(\ell)}_u \mid u \in N_v, a^{(\ell)}_u = \text{S or B} \} \right) &amp; \text{if } a^{(\ell)}_v = \text{L or S} \end{cases}\] </li> <li><strong>Layer-wise Update</strong>: <ul> <li>A Co-GNN layer involves predicting actions, sampling them, and updating node states.</li> <li>Repeated for L layers to obtain final node representations \(\large{h^{(L)}_v}\) .</li> </ul> </li> </ol> <h3 id="environment-network-η-details"><strong>Environment Network η Details</strong></h3> <p>The environment network updates node states using a message-passing scheme based on the selected actions. Let’s consider the standard GCN layer and how it adapts to Co-GNN concepts:</p> <ol> <li><strong>Message Aggregation</strong>: <ul> <li>For each node v , aggregate messages from its neighbors u that are broadcasting or using the standard action. \(m_v^{(\ell)} = \sum_{u \in N_v, a_u^{(\ell)}\ =\ \text{S or B}} h_u^{(\ell)}\)</li> </ul> </li> <li><strong>Node Update</strong>: <ul> <li>The node updates its state based on the aggregated messages and its current state. \(h_v^{(\ell+1)} = \sigma \left( W^{(\ell)}_s h_v^{(\ell)} + W^{(\ell)}_n m_v^{(\ell)} \right)\)</li> </ul> </li> </ol> <h3 id="properties-and-benefits"><strong>Properties and Benefits</strong></h3> <ul> <li><strong>Task-specific</strong>: Nodes learn to focus on relevant neighbors based on the task.</li> <li><strong>Directed</strong>: Edges can become directed, influencing directional information flow.</li> <li><strong>Dynamic and Feature-based</strong>: Adapt to changing graph structures and node features.</li> <li><strong>Asynchronous Updates</strong>: Nodes can be updated independently.</li> <li><strong>Expressive Power</strong>: More expressive than traditional GNNs, capable of handling long-range dependencies and reducing over-squashing and over-smoothing.</li> </ul> <h3 id="example-implementation"><strong>Example Implementation</strong></h3> <p>Consider a GCN (Graph Convolutional Network) adapted with Co-GNN concepts:</p> <ol> <li> <p><strong>GCN Layer (Traditional)</strong>:</p> \[h^{(\ell+1)}_v = \sigma \left( W^{(\ell)}_s h^{(\ell)}_v + W^{(\ell)}_n \sum_{u \in N_v} h^{(\ell)}_u \right)\] </li> <li> <p><strong>Co-GNN Layer</strong>:</p> <ul> <li><strong>Action Network</strong>: Predicts action probabilities for each node.</li> </ul> \[p^{(\ell)}_v = \text{Softmax} \left( W_a h^{(\ell)}_v + b_a \right)\] <ul> <li> <p><strong>Action Sampling</strong>: Gumbel-softmax to select actions. \(a^{(\ell)}_v \sim \text{Gumbel-Softmax}(p^{(\ell)}_v)\)</p> </li> <li> <p><strong>State Update (Environment Network)</strong>:</p> </li> </ul> \[h^{(\ell+1)}_v = \begin{cases} \sigma \left( W^{(\ell)}_s h^{(\ell)}_v \right) &amp; \text{if } a^{(\ell)}_v = \text{I or B} \\ \sigma \left( W^{(\ell)}_s h^{(\ell)}_v + W^{(\ell)}_n \sum_{u \in N_v, a^{(\ell)}_u = \text{S or B}} h^{(\ell)}_u \right) &amp; \text{if } a^{(\ell)}_v = \text{L or S} \end{cases}\] </li> </ol> <h2 id="conclusion">Conclusion</h2> <p>Co-GNNs represent a significant advancement in GNN architectures, offering a dynamic and adaptive message-passing framework that improves the handling of complex graph structures and long-range dependencies. The introduction of the Action Network and Environment Network provides a more flexible and task-specific approach to node state updates, leading to superior performance on various graph-related tasks.</p> <p>For further details, refer to the <a href="https://arxiv.org/abs/2310.01267">manuscript</a>.</p> <h2 id="integrating-co-gnn-concepts-into-mace">Integrating Co-GNN Concepts into MACE</h2> <h3 id="1-node-representation"><strong>1. Node Representation</strong></h3> <p>Each node i is represented by:</p> \[\large{\sigma_i^{(t)} = (r_i, z_i, h_i^{(t)})}\] <p>where \(r_i \in \mathbb{R}^3\) is the position, \(z_i\) is the chemical element, and \(h_i^{(t)}\) are the learnable features at layer \(t\).</p> <h4 id="2-action-network-π"><strong>2. Action Network (π)</strong></h4> <p>For each atom i at layer t, the Action Network \(\pi\) predicts a probability distribution over actions {S, L, B, I}:</p> \[\large{p_i^{(t)} = \pi(\sigma_i^{(t)}, \{\sigma_j^{(t)} | j \in N(i)\})}\] <h4 id="3-action-sampling"><strong>3. Action Sampling</strong></h4> <p>Actions are sampled using the Straight-through Gumbel-softmax estimator:</p> \[\large{a_i^{(t)} \sim \text{Gumbel-Softmax}(p_i^{(t)})}\] <h4 id="4-message-construction"><strong>4. Message Construction</strong></h4> <p>Messages are constructed hierarchically using body order expansion, modified to consider only neighbors that are broadcasting (B) or using the standard action (S):</p> \[\large{m_i^{(t)} = \sum_{j \in N(i), a_j^{(t)} \in \{S, B\}} u_1(\sigma_i^{(t)}, \sigma_j^{(t)}) + \sum_{j_1, j_2 \in N(i), a_{j_1}^{(t)} \in \{S, B\}, a_{j_2}^{(t)} \in \{S, B\}} u_2(\sigma_i^{(t)}, \sigma_{j_1}^{(t)}, \sigma_{j_2}^{(t)}) + \cdots + \sum_{j_1, \ldots, j_\nu \in N(i), a_{j_1}^{(t)} \in \{S, B\}, \ldots, a_{j_\nu}^{(t)} \in \{S, B\}} u_\nu(\sigma_i^{(t)}, \sigma_{j_1}^{(t)}, \ldots, \sigma_{j_\nu}^{(t)})}\] <p>For the two-body interactions:</p> \[\large{A_i^{(t)} = \sum_{j \in N(i), a_j^{(t)} \in \{S, B\}} R_{kl_1l_2l_3}^{(t)}(r_{ij}) Y_{l_1}^{m_1}(\hat{r}_{ij}) W_{kk_2l_2}^{(t)} h_{j,k_2l_2m_2}^{(t)}}\] <p>where R is a learnable radial basis, Y are spherical harmonics, and W are learnable weights.</p> <h4 id="5-higher-order-feature-construction"><strong>5. Higher-order Feature Construction</strong></h4> <p>Higher-order features are constructed using tensor products and symmetrization, modified to consider the actions of neighboring atoms:</p> \[\large{B_{i, \eta \nu k LM}^{(t)} = \sum_{lm} C_{LM \eta \nu, lm} \prod_{\xi=1}^\nu \sum_{k_\xi} w_{kk_\xi l_\xi}^{(t)} A_{i, k_\xi l_\xi m_\xi}^{(t)}}\] <p>where C are generalized Clebsch-Gordan coefficients.</p> <h4 id="6-state-update-environment-network-η"><strong>6. State Update (Environment Network η)</strong></h4> <p>The state update is modified based on the sampled actions:</p> <ul> <li>If \(a_i^{(t)} \in \{L, S\}\):</li> </ul> \[\large{h_i^{(t+1)} = \eta^{(t)}(h_i^{(t)}, \{h_j^{(t)} | j \in N(i), a_j^{(t)} \in \{S, B\}\})}\] <ul> <li>If \(a_i^{(t)} \in \{I, B\}\):</li> </ul> \[\large{h_i^{(t+1)} = \eta^{(t)}(h_i^{(t)}, \{\})}\] <h4 id="7-readout-phase"><strong>7. Readout Phase</strong></h4> <p>In the readout phase, invariant features are mapped to site energies:</p> \[\large{E_i = E_i^{(0)} + E_i^{(1)} + \cdots + E_i^{(T)}}\] <p>where:</p> \[\large{E_i^{(t)} = R_t(h_i^{(t)}) = \sum_{k'} W_{\text{readout}, k'}^{(t)} h_{i, k' 00}^{(t)} \quad \text{for } t &lt; T}\] \[\large{E_i^{(T)} = \text{MLP}_{\text{readout}}^{(t)}(\{h_{i, k 00}^{(t)}\})}\] <h4 id="8-equivariance"><strong>8. Equivariance</strong></h4> <p>The model ensures equivariance under rotation \(Q \in O(3)\) :</p> \[\large{h_i^{(t)}(Q \cdot (r_1, \ldots, r_N)) = D(Q) h_i^{(t)}(r_1, \ldots, r_N)}\] <p>where \(D(Q)\) is a Wigner D-matrix. For feature \(\large{h_{i, k LM}^{(t)}}\) , it transforms as:</p> \[\large{h_{i, k LM}^{(t)}(Q \cdot (r_1, \ldots, r_N)) = \sum_{M'} D_L(Q)_{M'M} h_{i, k LM'}^{(t)}(r_1, \ldots, r_N)}\] <h2 id="2-conclusion">(2) Conclusion</h2> <p>By incorporating the dynamic message-passing strategy of Co-GNNs into the MACE framework, we can enhance its flexibility and adaptability. This involves using an Action Network to determine the message-passing strategy for each atom, modifying the message construction and state update equations accordingly. This integration retains the equivariance properties of MACE while potentially improving its expressiveness and ability to capture complex interactions(?).</p>]]></content><author><name></name></author><category term="worklog"/><category term="MLP"/><category term="neural-network"/><summary type="html"><![CDATA[Some crucial ideas from Finklestein et al.'s work on Cooperative GNNs]]></summary></entry><entry><title type="html">E(3) - equivariant GNN with Learnable Activation Functions on Edges</title><link href="https://utksi.github.io/blog/2024/gnn_kan/" rel="alternate" type="text/html" title="E(3) - equivariant GNN with Learnable Activation Functions on Edges"/><published>2024-04-21T22:31:00+00:00</published><updated>2024-04-21T22:31:00+00:00</updated><id>https://utksi.github.io/blog/2024/gnn_kan</id><content type="html" xml:base="https://utksi.github.io/blog/2024/gnn_kan/"><![CDATA[<ul> <li>KANs proposed by <a href="https://arxiv.org/abs/2404.19756">Liu et al.</a>.</li> <li>See <a href="https://github.com/GistNoesis/FourierKAN">Fourier-KAN</a> implementation, replaces splines with fourier coefficients.</li> </ul> <h2 id="general-message-passing-neural-network-mpnn">General Message Passing Neural Network (MPNN)</h2> <ol> <li> <p><strong>Input Node and Edge Features</strong>:</p> <ul> <li>Nodes: \(\mathbf{x}_i\) (node features)</li> <li>Edges: \(\mathbf{e}_{ij}\) (edge features)</li> </ul> </li> <li> <p><strong>Message Passing Layer</strong> (per layer):</p> <p>a. <strong>Edge Feature Transformation</strong>:</p> \[\mathbf{e}'_{ij} = f_e(\mathbf{e}_{ij})\] <p>where \(f_e\) is a transformation function applied to edge features.</p> <p>b. <strong>Message Computation</strong>:</p> \[\mathbf{m}_{ij} = f_m(\mathbf{x}_i, \mathbf{x}_j, \mathbf{e}'_{ij})\] <p>where \(f_m\) computes messages using node features \(\mathbf{x_i} ,\ \mathbf{x_j}\), and transformed edge features \(\mathbf{e}'_{ij}\).</p> <p>c. <strong>Message Aggregation</strong>:</p> \[\mathbf{m}_i = \sum_{j \in \mathcal{N}(i)} \mathbf{m}_{ij}\] <p>where \(\mathcal{N}(i)\) denotes the set of neighbors of node \(i\).</p> <p>d. <strong>Node Feature Update</strong>:</p> \[\mathbf{x}'_i = f_n(\mathbf{x}_i, \mathbf{m}_i)\] <p>where \(f_n\) updates node features using the aggregated messages \(\mathbf{m}_i\).</p> </li> <li> <p><strong>Output Node and Edge Features</strong>:</p> <ul> <li>Nodes: \(\mathbf{x}'_i\) (updated node features)</li> <li>Edges: \(\mathbf{e}'_{ij}\) (updated edge features)</li> </ul> </li> </ol> <h2 id="e3-equivariant-gnn-with-learnable-activation-functions-on-edges">E3-Equivariant GNN with Learnable Activation Functions on Edges</h2> <ol> <li> <p><strong>Input Node and Edge Features</strong>:</p> <ul> <li>Nodes: \(\mathbf{x}_i\) (node features)</li> <li>Edges: \(\mathbf{e}_{ij}\) (edge features)</li> </ul> </li> <li> <p><strong>Learnable Edge Feature Transformation</strong>:</p> <ul> <li> <p><strong>Fourier-based Edge Transformation</strong>:</p> \[\mathbf{e}'_{ij} = \text{FourierTransform}(\mathbf{e}_{ij})\] <p>where the Fourier transformation is applied to edge features. Specifically, the transformation is defined as:</p> \[\mathbf{e}'_{ij} = \sum_{k=1}^{K} a_{ij,k} \cos(k \mathbf{e}_{ij}) + b_{ij,k} \sin(k \mathbf{e}_{ij})\] <p>Here, \(a_{ij,k}\) and \(b_{ij,k}\) are learnable parameters, and \(K\) is the number of Fourier terms.</p> </li> </ul> </li> <li> <p><strong>Message Passing and Aggregation</strong>:</p> <p>a. <strong>Message Computation</strong>:</p> \[\mathbf{m}_{ij} = \mathbf{e}'_{ij} \odot \mathbf{x}_j\] <p>where \(\odot\) denotes element-wise multiplication, combining the transformed edge features \(\mathbf{e}'_{ij}\) with the neighboring node features \(\mathbf{x}_j\).</p> <p>b. <strong>Message Aggregation</strong>:</p> \[\mathbf{m}_i = \sum_{j \in \mathcal{N}(i)} \mathbf{m}_{ij}\] <p>c. <strong>Simple Node Feature Transformation</strong>:</p> \[\mathbf{x}'_i = \mathbf{W} (\mathbf{x}_i + \mathbf{m}_i) + \mathbf{b}\] <p>where \(\mathbf{W}\) is a learnable weight matrix and \(\mathbf{b}\) is a bias vector.</p> </li> <li> <p><strong>Output Node and Edge Features</strong>:</p> <ul> <li>Nodes: \(\mathbf{x}'_i\) (updated node features)</li> <li>Edges: \(\mathbf{e}'_{ij}\) (updated edge features)</li> </ul> </li> </ol> <h2 id="full-implementation">Full Implementation</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">torch</span>
<span class="kn">import</span> <span class="n">torch.nn</span> <span class="k">as</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="n">torch_scatter</span> <span class="kn">import</span> <span class="n">scatter_add</span>
<span class="kn">from</span> <span class="n">torch_geometric.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="n">torch_geometric.datasets</span> <span class="kn">import</span> <span class="n">QM9</span>
<span class="kn">from</span> <span class="n">torch_geometric.transforms</span> <span class="kn">import</span> <span class="n">Distance</span>
<span class="kn">from</span> <span class="n">torch_geometric.nn</span> <span class="kn">import</span> <span class="n">MessagePassing</span>
<span class="kn">from</span> <span class="n">torch.optim</span> <span class="kn">import</span> <span class="n">Adam</span>
<span class="kn">from</span> <span class="n">e3nn</span> <span class="kn">import</span> <span class="n">o3</span>
<span class="kn">from</span> <span class="n">e3nn.nn</span> <span class="kn">import</span> <span class="n">Gate</span><span class="p">,</span> <span class="n">FullyConnectedNet</span>


<span class="k">class</span> <span class="nc">LearnableActivationEdge</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Class to define learnable activation functions on edges using Fourier series.
    Inspired by Kolmogorov-Arnold Networks (KANs) to capture complex, non-linear transformations on edge features.
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">inputdim</span><span class="p">,</span> <span class="n">outdim</span><span class="p">,</span> <span class="n">num_terms</span><span class="p">,</span> <span class="n">addbias</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Initialize the LearnableActivationEdge module.

        Args:
            inputdim (int): Dimension of input edge features.
            outdim (int): Dimension of output edge features.
            num_terms (int): Number of Fourier terms.
            addbias (bool): Whether to add a bias term. Default is True.
        </span><span class="sh">"""</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">LearnableActivationEdge</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>

        <span class="n">self</span><span class="p">.</span><span class="n">num_terms</span> <span class="o">=</span> <span class="n">num_terms</span>
        <span class="n">self</span><span class="p">.</span><span class="n">addbias</span> <span class="o">=</span> <span class="n">addbias</span>
        <span class="n">self</span><span class="p">.</span><span class="n">inputdim</span> <span class="o">=</span> <span class="n">inputdim</span>
        <span class="n">self</span><span class="p">.</span><span class="n">outdim</span> <span class="o">=</span> <span class="n">outdim</span>

        <span class="c1"># Initialize learnable Fourier coefficients
</span>        <span class="n">self</span><span class="p">.</span><span class="n">fouriercoeffs</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Parameter</span><span class="p">(</span>
            <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">outdim</span><span class="p">,</span> <span class="n">inputdim</span><span class="p">,</span> <span class="n">num_terms</span><span class="p">)</span> <span class="o">/</span>
            <span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">inputdim</span><span class="p">))</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">num_terms</span><span class="p">)))</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">addbias</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">outdim</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">edge_attr</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Forward pass to apply learnable activation functions on edge attributes.

        Args:
            edge_attr (Tensor): Edge attributes of shape (..., inputdim).

        Returns:
            Tensor: Transformed edge attributes of shape (..., outdim).
        </span><span class="sh">"""</span>
        <span class="n">xshp</span> <span class="o">=</span> <span class="n">edge_attr</span><span class="p">.</span><span class="n">shape</span>
        <span class="n">outshape</span> <span class="o">=</span> <span class="n">xshp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">outdim</span><span class="p">,)</span>
        <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">edge_attr</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">inputdim</span><span class="p">))</span>

        <span class="c1"># Generate Fourier terms
</span>        <span class="n">k</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_terms</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">edge_attr</span><span class="p">.</span><span class="n">device</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_terms</span><span class="p">)</span>
        <span class="n">xrshp</span> <span class="o">=</span> <span class="n">edge_attr</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Compute cosine and sine components
</span>        <span class="n">c</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">xrshp</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">xrshp</span><span class="p">)</span>

        <span class="c1"># Apply learnable Fourier coefficients
</span>        <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">fouriercoeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">fouriercoeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Add bias if applicable
</span>        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">addbias</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">bias</span>

        <span class="c1"># Reshape to original edge attribute shape
</span>        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">outshape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span>


<span class="k">class</span> <span class="nc">E3EquivariantGNN</span><span class="p">(</span><span class="n">MessagePassing</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    E(3)-Equivariant Graph Neural Network (GNN) that focuses on learnable activation functions on edges.
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">in_features</span><span class="p">,</span> <span class="n">out_features</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">num_terms</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Initialize the E3EquivariantGNN module.

        Args:
            in_features (int): Dimension of input node features.
            out_features (int): Dimension of output node features.
            hidden_dim (int): Dimension of hidden layers.
            num_layers (int): Number of layers in the network.
            num_terms (int): Number of Fourier terms for learnable activation functions.
        </span><span class="sh">"""</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">E3EquivariantGNN</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">(</span><span class="n">aggr</span><span class="o">=</span><span class="sh">'</span><span class="s">add</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">num_layers</span> <span class="o">=</span> <span class="n">num_layers</span>

        <span class="c1"># Define the input and output irreps (representations)
</span>        <span class="n">self</span><span class="p">.</span><span class="n">input_irrep</span> <span class="o">=</span> <span class="n">o3</span><span class="p">.</span><span class="n">Irreps</span><span class="p">.</span><span class="nf">spherical_harmonics</span><span class="p">(</span><span class="n">lmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Example irreps, adjust as needed
</span>        <span class="n">self</span><span class="p">.</span><span class="n">output_irrep</span> <span class="o">=</span> <span class="n">o3</span><span class="p">.</span><span class="nc">Irreps</span><span class="p">([(</span><span class="n">out_features</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))])</span>  <span class="c1"># Scalar output
</span>
        <span class="c1"># Define the hidden irreps
</span>        <span class="n">hidden_irreps</span> <span class="o">=</span> <span class="p">[</span><span class="n">o3</span><span class="p">.</span><span class="n">Irreps</span><span class="p">.</span><span class="nf">spherical_harmonics</span><span class="p">(</span><span class="n">lmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_layers</span><span class="p">)]</span>  <span class="c1"># Adjust as needed
</span>
        <span class="c1"># Create the equivariant layers and learnable activation functions on edges
</span>        <span class="n">self</span><span class="p">.</span><span class="n">fourier_layers</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ModuleList</span><span class="p">([</span>
            <span class="nc">LearnableActivationEdge</span><span class="p">(</span><span class="n">in_features</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">hidden_dim</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">,</span> <span class="n">num_terms</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_layers</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">layers</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ModuleList</span><span class="p">([</span>
            <span class="nc">Gate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">input_irrep</span><span class="p">,</span> <span class="n">hidden_irreps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="n">num_terms</span><span class="p">),</span>
            <span class="o">*</span><span class="p">[</span><span class="nc">Gate</span><span class="p">(</span><span class="n">hidden_irreps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hidden_irreps</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="n">num_terms</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)],</span>
            <span class="nc">Gate</span><span class="p">(</span><span class="n">hidden_irreps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">output_irrep</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="n">num_terms</span><span class="p">)</span>
        <span class="p">])</span>

        <span class="c1"># Output layer
</span>        <span class="n">self</span><span class="p">.</span><span class="n">output_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">out_features</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">edge_attr</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Forward pass to propagate node features through the GNN.

        Args:
            x (Tensor): Node features of shape (num_nodes, in_features).
            edge_index (Tensor): Edge indices of shape (2, num_edges).
            edge_attr (Tensor): Edge attributes of shape (num_edges, edge_dim).

        Returns:
            Tensor: Output node features of shape (num_nodes, out_features).
        </span><span class="sh">"""</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">edge_index</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">num_layers</span><span class="p">):</span>
            <span class="c1"># Transform edge features with Fourier series
</span>            <span class="n">fourier_messages</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">fourier_layers</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">edge_attr</span><span class="p">)</span>

            <span class="c1"># Apply equivariant transformations to node features
</span>            <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="n">fourier_messages</span><span class="p">)</span>

            <span class="c1"># Compute messages
</span>            <span class="n">m_ij</span> <span class="o">=</span> <span class="n">fourier_messages</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>

            <span class="c1"># Aggregate messages
</span>            <span class="n">m_i</span> <span class="o">=</span> <span class="nf">scatter_add</span><span class="p">(</span><span class="n">m_ij</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim_size</span><span class="o">=</span><span class="n">x</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1"># Update node features
</span>            <span class="n">x</span> <span class="o">=</span> <span class="n">m_i</span>

        <span class="c1"># Apply the final linear layer
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">output_layer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>


<span class="c1"># Load and prepare the QM9 dataset
</span><span class="n">dataset</span> <span class="o">=</span> <span class="nc">QM9</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="sh">'</span><span class="s">data/QM9</span><span class="sh">'</span><span class="p">)</span>
<span class="n">dataset</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="nc">Distance</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># Split dataset into training, validation, and test sets
</span><span class="n">train_dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[:</span><span class="mi">110000</span><span class="p">]</span>
<span class="n">val_dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">110000</span><span class="p">:</span><span class="mi">120000</span><span class="p">]</span>
<span class="n">test_dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">120000</span><span class="p">:]</span>

<span class="c1"># Data loaders for training, validation, and test sets
</span><span class="n">train_loader</span> <span class="o">=</span> <span class="nc">DataLoader</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">val_loader</span> <span class="o">=</span> <span class="nc">DataLoader</span><span class="p">(</span><span class="n">val_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">test_loader</span> <span class="o">=</span> <span class="nc">DataLoader</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># Define the loss function and optimizer
</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">MSELoss</span><span class="p">()</span>
<span class="n">model</span> <span class="o">=</span> <span class="nc">E3EquivariantGNN</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">num_layers</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_terms</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="nc">Adam</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">train_step</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Perform a single training step.

    Args:
        model (nn.Module): The neural network model.
        optimizer (Optimizer): The optimizer.
        criterion (Loss): The loss function.
        data (Data): The input data batch.

    Returns:
        float: The loss value.
    </span><span class="sh">"""</span>
    <span class="n">model</span><span class="p">.</span><span class="nf">train</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">edge_attr</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="nf">criterion</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
    <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span>


<span class="c1"># Training loop
</span><span class="n">num_epochs</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">):</span>
    <span class="n">train_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">train_loader</span><span class="p">:</span>
        <span class="n">train_loss</span> <span class="o">+=</span> <span class="nf">train_step</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">train_loss</span> <span class="o">/=</span> <span class="nf">len</span><span class="p">(</span><span class="n">train_loader</span><span class="p">)</span>

    <span class="n">val_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">no_grad</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">val_loader</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">edge_attr</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="nf">criterion</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">val_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span>
    <span class="n">val_loss</span> <span class="o">/=</span> <span class="nf">len</span><span class="p">(</span><span class="n">val_loader</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Epoch </span><span class="si">{</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s">, Train Loss: </span><span class="si">{</span><span class="n">train_loss</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s">, Val Loss: </span><span class="si">{</span><span class="n">val_loss</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="detailed-explanation-of-mathematical-formulations">Detailed Explanation of Mathematical Formulations</h2> <h3 id="learnable-edge-feature-transformation">Learnable Edge Feature Transformation</h3> <p>For each edge \((i, j)\) with feature \(\mathbf{e}_{ij}\):</p> \[\mathbf{e}'_{ij} = \sum_{k=1}^{K} a_{ij,k} \cos(k \mathbf{e}_{ij}) + b_{ij,k} \sin(k \mathbf{e}_{ij})\] <p>where \(a_{ij,k}\) and \(b_{ij,k}\) are learnable parameters, and \(K\) is the number of terms.</p> <h3 id="message-computation">Message Computation</h3> <p>For each edge \((i, j)\):</p> \[\mathbf{m}_{ij} = \mathbf{e}'_{ij} \odot \mathbf{x}_j\] <p>where \(\odot\) denotes element-wise multiplication.</p> <h3 id="message-aggregation">Message Aggregation</h3> <p>For each node \(i\):</p> \[\mathbf{m}_i = \sum_{j \in \mathcal{N}(i)} \mathbf{m}_{ij}\] <p>where \(\mathcal{N}(i)\) denotes the set of neighbors of node \(i\).</p> <h3 id="node-feature-update">Node Feature Update</h3> <p>For each node \(i\):</p> \[\mathbf{x}'_i = \mathbf{W} (\mathbf{x}_i + \mathbf{m}_i) + \mathbf{b}\] <p>where \(\mathbf{W}\) is a learnable weight matrix and \(\mathbf{b}\) is a bias vector.</p> <h2 id="summary">Summary</h2> <p>This implementation combines the learnable activation functions on edges with E(3) equivariant transformations on node features. The detailed mathematical formulations provided in the comments explain each step of the process, making it suitable for a physicist audience familiar with these concepts.</p> <p>..#Idea #TODO: KANs for learnable edge activations in MACE - to have it as an option. Train on the same set.</p>]]></content><author><name></name></author><category term="worklog"/><category term="machine-learning"/><category term="neural-network"/><category term="GNN"/><category term="NN"/><summary type="html"><![CDATA[Some ideas about KAN-based GNNs beyond just stacking layers]]></summary></entry><entry><title type="html">[Stuff I read] Kolmogorov Arnold Networks</title><link href="https://utksi.github.io/blog/2024/kan/" rel="alternate" type="text/html" title="[Stuff I read] Kolmogorov Arnold Networks"/><published>2024-04-18T22:31:00+00:00</published><updated>2024-04-18T22:31:00+00:00</updated><id>https://utksi.github.io/blog/2024/kan</id><content type="html" xml:base="https://utksi.github.io/blog/2024/kan/"><![CDATA[<ul> <li>Proposed by Max Tegmark’s group. See <a href="https://arxiv.org/abs/2404.19756">Liu et al</a></li> <li>A hot topic on twitter - a matter of a lot of debate.</li> </ul> <p>The paper “KAN: Kolmogorov–Arnold Networks” proposes Kolmogorov-Arnold Networks (KANs) as an alternative to Multi-Layer Perceptrons (MLPs). The core idea behind KANs is inspired by the Kolmogorov-Arnold representation theorem, which states that any multivariate continuous function can be represented as a sum of continuous functions of one variable. This section will summarize the technical details of the paper, focusing on the mathematical formulations.</p> <h3 id="1-introduction">1. Introduction</h3> <p>The motivation for KANs stems from the limitations of MLPs, such as fixed activation functions on nodes and linear weights. MLPs rely heavily on the universal approximation theorem, but their structure can be less efficient and interpretable. KANs, on the other hand, utilize learnable activation functions on edges and replace linear weights with univariate functions parametrized as splines.</p> <h3 id="2-kolmogorov-arnold-representation-theorem">2. Kolmogorov-Arnold Representation Theorem</h3> <p>The Kolmogorov-Arnold representation theorem states:</p> \[f(x) = \sum_{q=1}^{2n+1} \Phi_q \left( \sum_{p=1}^n \varphi_{q,p}(x_p) \right)\] <p>where \(\varphi_{q,p} : [0, 1] \to \mathbb{R}\) and \(\Phi_q : \mathbb{R} \to \mathbb{R}\).</p> <h3 id="3-kan-architecture">3. KAN Architecture</h3> <p>KANs generalize the representation theorem to arbitrary depths and widths. Each weight parameter in KANs is replaced by a learnable 1D function (spline).</p> <h4 id="31-mathematical-formulation-of-kans">3.1. Mathematical Formulation of KANs</h4> <p>Define a KAN layer with \(n_{\text{in}}\)-dimensional inputs and \(n_{\text{out}}\)-dimensional outputs as a matrix of 1D functions:</p> \[\Phi = \{ \varphi_{q,p} \}, \quad p = 1, 2, \ldots, n_{\text{in}}, \quad q = 1, 2, \ldots, n_{\text{out}}\] <p>Activation function on edge \(\varphi_{l,j,i}\) between layer \(l\) and \(l+1\) is given by:</p> \[\varphi_{l,j,i}(x) = w (b(x) + \text{spline}(x))\] <p>where \(b(x) = \text{silu}(x) = \frac{x}{1 + e^{-x}}\).</p> <p>The output of each layer is computed as:</p> \[x_{l+1, j} = \sum_{i=1}^{n_l} \varphi_{l,j,i}(x_{l,i})\] <p>in matrix form:</p> \[x_{l+1} = \Phi_l x_l\] <p>where \(\Phi_l\) is the function matrix of layer \(l\).</p> <h3 id="4-approximation-abilities-and-scaling-laws">4. Approximation Abilities and Scaling Laws</h3> <p>KANs can approximate functions by decomposing high-dimensional problems into several 1D problems, effectively avoiding the curse of dimensionality.</p> <h4 id="theorem-21-approximation-bound">Theorem 2.1: Approximation Bound</h4> <p>Let \(f(x)\) be represented as:</p> \[f = (\Phi_{L-1} \circ \Phi_{L-2} \circ \cdots \circ \Phi_1 \circ \Phi_0)x\] <p>For each \(\Phi_{l,i,j}\), there exist \(k\)-th order B-spline functions \(\Phi_{l,i,j}^G\) such that:</p> \[\| f - (\Phi_{L-1}^G \circ \Phi_{L-2}^G \circ \cdots \circ \Phi_1^G \circ \Phi_0^G)x \|_{C^m} \leq C G^{-k-1+m}\] <p>where \(G\) is the grid size and \(C\) depends on \(f\) and its representation.</p> <h3 id="5-grid-extension-technique">5. Grid Extension Technique</h3> <p>KANs can increase accuracy by refining the grid used in splines:</p> \[\{c'_j\} = \arg\min_{\{c'_j\}} E_{x \sim p(x)} \left( \sum_{j=0}^{G2+k-1} c'_j B'_j(x) - \sum_{i=0}^{G1+k-1} c_i B_i(x) \right)^2\] <h3 id="6-simplification-techniques">6. Simplification Techniques</h3> <p>KANs can be made more interpretable by sparsification, pruning, and symbolification. The L1 norm and entropy regularization can be used to sparsify the network.</p> <h3 id="7-toy-examples-and-empirical-results">7. Toy Examples and Empirical Results</h3> <p>KANs were shown to have better scaling laws than MLPs, achieving lower test losses with fewer parameters in various toy datasets and special functions.</p> <h4 id="example-functions">Example Functions</h4> <ol> <li>Bessel function: \(f(x) = J_0(20x)\)</li> <li>High-dimensional function: \(f(x_1, \ldots, x_{100}) = \exp\left( \frac{1}{100} \sum_{i=1}^{100} \sin^2(\pi x_i / 2) \right)\)</li> </ol> <p>KANs can achieve near-theoretical scaling exponents \(\alpha = 4\), outperforming MLPs in accuracy and parameter efficiency.</p> <h3 id="conclusion">Conclusion</h3> <p>KANs provide a novel approach to neural network design, leveraging the Kolmogorov-Arnold representation theorem to achieve better performance and interpretability compared to traditional MLPs. The use of learnable activation functions on edges and splines allows for greater flexibility and efficiency in function approximation.</p>]]></content><author><name></name></author><category term="stuff-i-read"/><category term="neural-network"/><category term="NN"/><summary type="html"><![CDATA[A very short summary of main ideas from Liu et al.]]></summary></entry><entry><title type="html">MACE (Message Passing ACE)</title><link href="https://utksi.github.io/blog/2023/mace/" rel="alternate" type="text/html" title="MACE (Message Passing ACE)"/><published>2023-08-01T22:36:00+00:00</published><updated>2023-08-01T22:36:00+00:00</updated><id>https://utksi.github.io/blog/2023/mace</id><content type="html" xml:base="https://utksi.github.io/blog/2023/mace/"><![CDATA[<h3 id="introduction"><strong>Introduction</strong></h3> <p>MACE (Message Passing Atomic Cluster Expansion) is an equivariant message passing neural network that uses higher-order messages to enhance the accuracy and efficiency of force fields in computational chemistry.</p> <h3 id="node-representation"><strong>Node Representation</strong></h3> <p>Each node \(\large{i}\) is represented by:</p> \[\large{\sigma_i^{(t)} = (r_i, z_i, h_i^{(t)})}\] <p>where \(r_i \in \mathbb{R}^3\) is the position, \(\large{z_i}\) is the chemical element, and \(\large{h_i^{(t)}}\) are the learnable features at layer \(\large{t}\).</p> <h3 id="message-construction"><strong>Message Construction</strong></h3> <p>Messages are constructed hierarchically using a body order expansion:</p> \[m_i^{(t)} = \sum_j u_1(\sigma_i^{(t)}, \sigma_j^{(t)}) + \sum_{j_1, j_2} u_2(\sigma_i^{(t)}, \sigma_{j_1}^{(t)}, \sigma_{j_2}^{(t)}) + \cdots + \sum_{j_1, \ldots, j_\nu} u_\nu(\sigma_i^{(t)}, \sigma_{j_1}^{(t)}, \ldots, \sigma_{j_\nu}^{(t)})\] <h3 id="two-body-message-construction"><strong>Two-body Message Construction</strong></h3> <p>For two-body interactions, the message \(m_i^{(t)}\) is:</p> \[A_i^{(t)} = \sum_{j \in N(i)} R_{kl_1l_2l_3}^{(t)}(r_{ij}) Y_{l_1}^{m_1}(\hat{r}_{ij}) W_{kk_2l_2}^{(t)} h_{j,k_2l_2m_2}^{(t)}\] <p>where \(\large{R}\) is a learnable radial basis, \(\large{Y}\) are spherical harmonics, and \(\large{W}\) are learnable weights. \(\large{C}\) are Clebsch-Gordan coefficients ensuring equivariance.</p> <h3 id="higher-order-feature-construction"><strong>Higher-order Feature Construction</strong></h3> <p>Higher-order features are constructed using tensor products and symmetrization:</p> \[\large{B_{i, \eta \nu k LM}^{(t)} = \sum_{lm} C_{LM \eta \nu, lm} \prod_{\xi=1}^\nu \sum_{k_\xi} w_{kk_\xi l_\xi}^{(t)} A_{i, k_\xi l_\xi m_\xi}^{(t)}}\] <p>where \(\large{C}\) are generalized Clebsch-Gordan coefficients.</p> <h3 id="message-passing"><strong>Message Passing</strong></h3> <p>The message passing updates the node features by aggregating messages:</p> \[\large{h_i^{(t+1)} = U_{kL}^{(t)}(\sigma_i^{(t)}, m_i^{(t)}) = \sum_{k'} W_{kL, k'}^{(t)} m_{i, k' LM} + \sum_{k'} W_{z_i kL, k'}^{(t)} h_{i, k' LM}^{(t)}}\] <h3 id="readout-phase"><strong>Readout Phase</strong></h3> <p>In the readout phase, invariant features are mapped to site energies:</p> \[\large{E_i = E_i^{(0)} + E_i^{(1)} + \cdots + E_i^{(T)}}\] <p>where:</p> \[\large{E_i^{(t)} = R_t(h_i^{(t)}) = \sum_{k'} W_{\text{readout}, k'}^{(t)} h_{i, k' 00}^{(t)} \quad \text{for } t &lt; T}\] \[\large{E_i^{(T)} = \text{MLP}_{\text{readout}}^{(t)}(\{h_{i, k 00}^{(t)}\})}\] <h3 id="equivariance"><strong>Equivariance</strong></h3> <p>The model ensures equivariance under rotation \(\large{Q \in O(3)}\) :</p> \[\large{h_i^{(t)}(Q \cdot (r_1, \ldots, r_N)) = D(Q) h_i^{(t)}(r_1, \ldots, r_N)}\] <p>where \(\large{D(Q)}\) is a Wigner D-matrix. For feature \(\large{h_{i, k LM}^{(t)}}\), it transforms as:</p> \[\large{h_{i, k LM}^{(t)}(Q \cdot (r_1, \ldots, r_N)) = \sum_{M'} D_L(Q)_{M'M} h_{i, k LM'}^{(t)}(r_1, \ldots, r_N)}\] <h2 id="properties-and-computational-efficiency">Properties and Computational Efficiency</h2> <ol> <li><strong>Body Order Expansion</strong>: <ul> <li>MACE constructs messages using higher body order expansions, enabling rich representations of atomic environments.</li> </ul> </li> <li><strong>Computational Efficiency</strong>: <ul> <li>The use of higher-order messages reduces the required number of message-passing layers to two, enhancing computational efficiency and scalability.</li> </ul> </li> <li><strong>Receptive Field</strong>: <ul> <li>MACE maintains a small receptive field by decoupling correlation order increase from the number of message-passing iterations, facilitating parallelization.</li> </ul> </li> <li><strong>State-of-the-Art Performance</strong>: <ul> <li>MACE achieves state-of-the-art accuracy on benchmark tasks (rMD17, 3BPA, AcAc), demonstrating its effectiveness in modeling complex atomic interactions.</li> </ul> </li> </ol> <p>For further details, refer to the <a href="https://arxiv.org/abs/2206.07697">Batatia et al.</a>.</p> <h2 id="necessary-math-to-know">Necessary math to know</h2> <h3 id="1-spherical-harmonics">1. <strong>Spherical Harmonics</strong></h3> <p><strong>Concept:</strong></p> <ul> <li>Spherical harmonics \(Y^L_M\) are functions defined on the surface of a sphere. They are used in many areas of physics, including quantum mechanics and electrodynamics, to describe the angular part of a system.</li> </ul> <p><strong>Role in MACE:</strong></p> <ul> <li>Spherical harmonics are used to decompose the angular dependency of the atomic environment. This helps in capturing the rotational properties of the features in a systematic way.</li> </ul> <p><strong>Mathematically:</strong></p> <ul> <li>The spherical harmonics \(Y^L_M(\theta, \phi)\) are given by:</li> </ul> \[Y^L_M(\theta, \phi) = \sqrt{\frac{(2L+1)}{4\pi} \frac{(L-M)!}{(L+M)!}} P^M_L(\cos \theta) e^{iM\phi}\] <p>where \(P^M_L\) are the associated Legendre polynomials.</p> <h3 id="2-clebsch-gordan-coefficients">2. <strong>Clebsch-Gordan Coefficients</strong></h3> <p><strong>Concept:</strong></p> <ul> <li>Clebsch-Gordan coefficients are used in quantum mechanics to combine angular momenta. They arise in the coupling of two angular momentum states to form a new angular momentum state.</li> </ul> <p><strong>Role in MACE:</strong></p> <ul> <li>In MACE, Clebsch-Gordan coefficients are used to combine features from different atoms while maintaining rotational invariance. They ensure that the resulting features transform correctly under rotations, preserving the physical symmetry of the system.</li> </ul> <p><strong>Mathematically:</strong></p> <ul> <li>When combining two angular momentum states \(\vert l_1, m_1\rangle\) and \(\vert l_2, m_2\rangle\), the resulting state \(\vert L, M\rangle\) is given by:</li> </ul> \[|L, M\rangle = \sum_{m_1, m_2} C_{L, M}^{l_1, m_1; l_2, m_2} |l_1, m_1\rangle |l_2, m_2\rangle\] <p>where \(C_{L, M}^{l_1, m_1; l_2, m_2}\) are the Clebsch-Gordan coefficients.</p> <h3 id="3-o3-rotations">3. <strong>\(O(3)\) Rotations</strong></h3> <p><strong>Concept:</strong></p> <ul> <li>The group \(O(3)\) consists of all rotations and reflections in three-dimensional space. It represents the symmetries of a 3D system, including operations that preserve the distance between points.</li> </ul> <p><strong>Role in MACE:</strong></p> <ul> <li>Ensuring that the neural network respects \(O(3)\) symmetry is crucial for modeling physical systems accurately. MACE achieves this by using operations that are invariant or equivariant under these rotations and reflections.</li> </ul> <p><strong>Mathematically:</strong></p> <ul> <li>A rotation in \(O(3)\) can be represented by a 3x3 orthogonal matrix \(Q\) such that:</li> </ul> \[Q^T Q = I \quad \text{and} \quad \det(Q) = \pm 1\] <p>where \(I\) is the identity matrix.</p> <h3 id="4-wigner-d-matrix">4. <strong>Wigner D-matrix</strong></h3> <p><strong>Concept:</strong></p> <ul> <li>The Wigner D-matrix \(D^L(Q)\) represents the action of a rotation \(Q\) on spherical harmonics. It provides a way to transform the components of a tensor under rotation.</li> </ul> <p><strong>Role in MACE:</strong></p> <ul> <li>Wigner D-matrices are used to ensure that the feature vectors in the neural network transform correctly under rotations. This is essential for maintaining the rotational equivariance of the model.</li> </ul> <p><strong>Mathematically:</strong></p> <ul> <li>For a rotation \(Q \in O(3)\) and a spherical harmonic of degree \(L\), the Wigner D-matrix \(D^L(Q)\) is a \((2L+1) \times (2L+1)\) matrix. If \(Y^L_M\) is a spherical harmonic, then under rotation \(Q\), it transforms as:</li> </ul> \[Y^L_M(Q \cdot \mathbf{r}) = \sum_{M'=-L}^{L} D^L_{M'M}(Q) Y^L_{M'}(\mathbf{r})\]]]></content><author><name></name></author><category term="worklog"/><category term="MLP"/><category term="NN"/><category term="neural-network"/><summary type="html"><![CDATA[A summary of Message Passing Atomic Cluster Expansion Graph Neural Networks]]></summary></entry></feed>