<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> ELF with wannier functions | Utkarsh Singh </title> <meta name="author" content="Utkarsh Singh"> <meta name="description" content="A worklog implementing calculation of Electron Localization Function (ELF) with wannier functions."> <meta name="keywords" content="physics, preovskite, optical, MLP, neural-network, NN, DFT, ab-initio"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/absorption2.png?d6e628c0dd411656b06d775fc45b63a7"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://utksi.github.io/blog/2024/wannier_elf/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Utkarsh</span> Singh </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">ELF with wannier functions</h1> <p class="post-meta"> Created in December 12, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/wannier"> <i class="fa-solid fa-hashtag fa-sm"></i> wannier</a>   <a href="/blog/tag/dft"> <i class="fa-solid fa-hashtag fa-sm"></i> DFT</a>   <a href="/blog/tag/elf"> <i class="fa-solid fa-hashtag fa-sm"></i> ELF</a>   <a href="/blog/tag/physics"> <i class="fa-solid fa-hashtag fa-sm"></i> physics</a>   ·   <a href="/blog/category/worklog"> <i class="fa-solid fa-tag fa-sm"></i> worklog</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <ul> <li> <p>This is not complete - in the sense that it is something, but no one yet knows if it is useful to have.</p> </li> <li> <p>For a primer on wannier functions: please see <a href="https://doi.org/10.1103/RevModPhys.96.045008" rel="external nofollow noopener" target="_blank">this</a>.</p> </li> <li> <p>In the event reading the following is not really needed, the implementation is available here: <a href="https://github.com/utksi/wannier_elf" rel="external nofollow noopener" target="_blank">Wannier-ELF</a></p> </li> </ul> <h3 id="what-and-why"><strong>What, and Why?</strong></h3> <p>The Electron Localization Function (ELF) is a valuable tool in computational chemistry and condensed matter physics for visualizing and understanding electron localization in atoms, molecules, and solids.</p> <p>Speaking informally, if one knows the degree of electron localization, a more generalized (as opposed to localized :D) perspective of bonding in the material of interest should be obtained. It is somewhat easier to think of this when looking at the math:</p> <p>The standard expression for ELF involves the kinetic energy densities:</p> \[\text{ELF}(\mathbf{r}) = \dfrac{1}{1 + \left( \dfrac{ t_P(\mathbf{r}) }{ t_h(\mathbf{r}) } \right)^2}\] <ul> <li>\(t_P(\mathbf{r}) = t(\mathbf{r}) - t_W(\mathbf{r})\): Pauli kinetic energy density.</li> <li>\(t(\mathbf{r})\): Total kinetic energy density.</li> <li>\(t_W(\mathbf{r})\): von Weizsäcker kinetic energy density.</li> <li>\(t_h(\mathbf{r})\): Kinetic energy density of a homogeneous electron gas.</li> </ul> <table> <tbody> <tr> <td>Essentially, it is a three-dimensional scalar field that <strong>tracks the variation in KE density</strong> (Total - Von-Weizsäcker term) at some point \(\mathbf{\vec{r}}\) in the cell, compared to if one had a homogeneous electron gas with the same electron density. (for which the gradient term: $$</td> <td>\nabla n(\mathbf{r})</td> <td>$$ should be exactly zero.)</td> </tr> </tbody> </table> <p>This ratio: \(\dfrac{ t_P(\mathbf{r}) }{ t_h(\mathbf{r}) }\) is also sometimes called the <strong>localization index</strong> : \(\chi (r)\).</p> <p>Given \(n(\mathbf{r})\): the electron density.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. **von Weizsäcker Kinetic Energy Density ($t_W(\mathbf{r})$)**

$$
t_W(\mathbf{r}) = \dfrac{1}{8} \dfrac{|\nabla n(\mathbf{r})|^2}{n(\mathbf{r})}
$$

2. **Pauli Kinetic Energy Density ($t_P(\mathbf{r})$)**

$$
t_P(\mathbf{r}) = t(\mathbf{r}) - t_W(\mathbf{r})
$$

3. **Homogeneous Electron Gas Kinetic Energy Density ($t_h(\mathbf{r})$)**
$$
t_h(\mathbf{r}) = \dfrac{3}{5} (3\pi^2)^{2/3} [n(\mathbf{r})]^{5/3}
$$
</code></pre></div></div> <h3 id="vaspcastep-expressions-for-elf">VASP/CASTEP expressions for ELF:</h3> <p>If you’re reading this, then it’s highly likely that you already know that ELF fields can be written very easily after a obtaining charge density in VASP/CASTEP.</p> <p>And, In CASTEP and VASP, the ELF is calculated using an expression involving the Laplacian of the Kohn-Sham orbitals and electron density:</p> \[D(\mathbf{r}) = -2A \sum_i \psi_i^*(\mathbf{r}) \nabla^2 \psi_i(\mathbf{r}) + \dfrac{A}{2} \nabla^2 n(\mathbf{r}) - \dfrac{A}{4n(\mathbf{r})} \left( \nabla n(\mathbf{r}) \right)^2\] <ul> <li>\(A = \dfrac{\hbar^2}{2m}\): Constant involving Planck’s constant \(\hbar\) and electron mass $m$.</li> <li>The terms represent: <ul> <li> <strong>First Term</strong>: Kinetic energy density of the non-interacting Kohn-Sham system.</li> <li> <strong>Second Term</strong>: “Correlation correction.”</li> <li> <strong>Third Term</strong>: Kinetic energy density of an ideal Bose gas at the same density.</li> </ul> </li> </ul> <p>The ELF is then calculated as:</p> \[\text{ELF}(\mathbf{r}) = \dfrac{1}{1 + \left( \dfrac{ D(\mathbf{r}) }{ D_0(\mathbf{r}) } \right)^2}\] <p>In the \(\texttt{VASP}\) source code, \(D(r) = T + T_{corr.} - T_{bos.}\) could be found, i.e. the same thing.</p> <p>The numerator in the localization index now looks a bit different here, and the first guess should be that this of course looks like this because the normal expression has been broken down into direct, cross and divergence terms - and one would be correct!</p> <p>I still find it a tiny bit cathartic to show this explicitly (doing my part against the entropy of the universe).</p> <h4 id="reconciling-the-expressions"><strong>Reconciling the Expressions</strong></h4> <h5 id="step-1-relate-the-first-term-to-total-kinetic-energy-density"><strong>Step 1: Relate the First Term to Total Kinetic Energy Density</strong></h5> <p>The first term in the CASTEP/VASP expression:</p> \[-2A \sum_i \psi_i^*(\mathbf{r}) \nabla^2 \psi_i(\mathbf{r})\] <p>Using the identity:</p> \[\psi_i^*(\mathbf{r}) \nabla^2 \psi_i(\mathbf{r}) = \nabla \cdot \left( \psi_i^*(\mathbf{r}) \nabla \psi_i(\mathbf{r}) \right) - |\nabla \psi_i(\mathbf{r})|^2\] <p>Substitute back:</p> \[-2A \sum_i \psi_i^*(\mathbf{r}) \nabla^2 \psi_i(\mathbf{r}) = 2A \sum_i |\nabla \psi_i(\mathbf{r})|^2 - 2A \sum_i \nabla \cdot \left( \psi_i^*(\mathbf{r}) \nabla \psi_i(\mathbf{r}) \right)\] <table> <tbody> <tr> <td>Recognizing that $A = \dfrac{\hbar^2}{2m}$, the term $$2A \sum_i</td> <td>\nabla \psi_i(\mathbf{r})</td> <td>^2$$ corresponds to twice the total kinetic energy density:</td> </tr> </tbody> </table> \[2 t(\mathbf{r}) = 2A \sum_i |\nabla \psi_i(\mathbf{r})|^2\] <h5 id="step-2-relate-the-second-and-third-terms-to-von-weizsäcker-kinetic-energy-density"><strong>Step 2: Relate the Second and Third Terms to von Weizsäcker Kinetic Energy Density</strong></h5> <p>The second term:</p> \[\dfrac{A}{2} \nabla^2 n(\mathbf{r}) = A \nabla \cdot \left( \dfrac{1}{2} \nabla n(\mathbf{r}) \right)\] <p>The third term:</p> \[- \dfrac{A}{4n(\mathbf{r})} \left( \nabla n(\mathbf{r}) \right)^2 = -2 t_W(\mathbf{r})\] <p>since:</p> \[t_W(\mathbf{r}) = \dfrac{1}{8} \dfrac{|\nabla n(\mathbf{r})|^2}{n(\mathbf{r})} = \dfrac{A}{4n(\mathbf{r})} |\nabla n(\mathbf{r})|^2\] <h5 id="step-3-combine-terms"><strong>Step 3: Combine Terms</strong></h5> <p>The total expression becomes:</p> \[D(\mathbf{r}) = 2 t(\mathbf{r}) - 2 t_W(\mathbf{r}) - 2A \sum_i \nabla \cdot \left( \psi_i^*(\mathbf{r}) \nabla \psi_i(\mathbf{r}) \right) + A \nabla \cdot \left( \dfrac{1}{2} \nabla n(\mathbf{r}) \right)\] <p>Group divergence terms:</p> \[D(\mathbf{r}) = 2 \left[ t(\mathbf{r}) - t_W(\mathbf{r}) \right] + \text{Divergence Terms}\] <p>Thus, we see that:</p> \[D(\mathbf{r}) = 2 t_P(\mathbf{r}) + \text{Divergence Terms}\] <h4 id="equivalence"><strong>Equivalence</strong></h4> <ul> <li>The CASTEP/VASP expression for $D(\mathbf{r})$ essentially represents twice the Pauli kinetic energy density $2 t_P(\mathbf{r})$, up to divergence terms.</li> <li>The divergence terms may cancel out or integrate to zero under appropriate boundary conditions but can be significant locally.</li> </ul> <h3 id="scalar-fields-with-wannier-functions">Scalar fields with Wannier functions:</h3> <p>The first step would be to recognize that we’re working with <em>Maximally localized</em> wannier functions. As as result, the phase is consistent.</p> <p>To that end, the solution should be simple.</p> <p>Given a scalar field \(w_n(r)\):</p> \[n(\mathbf{r}) = \sum_n^{\text{occ}} |\tilde{w}_n(\mathbf{r})|^2\] <p>And, calculate the kinetic energy density terms in the same way.</p> <p>Note that, at the end, we need \(D_h(r)\) and \(D(r) = \tau - \tau_w(r)\).</p> <h3 id="density-and-density-gradient-from-w_nr">Density and density-gradient from \(w_n(r)\):</h3> <p>In terms of implementation, the electron density and its gradient can be constructed as:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Process the wannier function.
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wf</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">wannier_data</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="sh">"</span><span class="s">Processing Wannier function </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">wannier_data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">smooth_sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">wf</span> <span class="o">=</span> <span class="nf">gaussian_filter</span><span class="p">(</span><span class="n">wf</span><span class="p">,</span> <span class="n">smooth_sigma</span><span class="p">)</span>

    <span class="c1"># No normalization - Wannier functions should already be normalized
</span>
    <span class="c1"># Accumulate density (e/Å³)
</span>    <span class="n">density</span> <span class="o">+=</span> <span class="n">wf</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># Calculate gradients (Å^-4)
</span>    <span class="n">grad_wf</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_gradient</span><span class="p">(</span><span class="n">wf</span><span class="p">)</span>

    <span class="c1"># Accumulate kinetic energy density (eV/Å³)
</span>    <span class="c1"># Using same prefactor as VASP for consistency
</span>    <span class="n">tau</span> <span class="o">+=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">grad_wf</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Accumulate density gradient (e/Å⁴)
</span>    <span class="n">grad_density</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">wf</span><span class="p">[...,</span> <span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">grad_wf</span>

<span class="c1"># Double density for non-spin-polarized system
</span><span class="n">density</span> <span class="o">*=</span> <span class="mf">2.0</span>
</code></pre></div></div> <h3 id="symmetrization-of-scalar-fields-fr">Symmetrization of scalar fields \(F(r)\):</h3> <p><strong>Strong</strong> emphasis needs to be laid on the importance of symmetrization of the charge density and kinetic energy scalar fields derived from wannier functions. Since the wannier functions are not <strong>symmetry-adapted</strong>, but <strong>maximally-localized</strong>, it matters quite a bit.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hint: Try to disable symmetrization in the code, or relax the constraints from 1e-5 to something higher; say, 1e-1; and see what happens.

See the <span class="sb">`symmetrize_field()`</span> function.
</code></pre></div></div> <p>The following symmetrizations are therefore essential.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Symmetrize fields
</span><span class="n">density</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">symmetrize_field</span><span class="p">(</span><span class="n">density</span><span class="p">,</span> <span class="sh">"</span><span class="s">density</span><span class="sh">"</span><span class="p">)</span>
<span class="n">tau</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">symmetrize_field</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="sh">"</span><span class="s">kinetic energy density</span><span class="sh">"</span><span class="p">)</span>
<span class="n">grad_density</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">symmetrize_field</span><span class="p">(</span><span class="n">grad_density</span><span class="p">,</span> <span class="sh">"</span><span class="s">density gradient</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Here is the symmetrization utility, which can do this both in real and reciprocal space. <code class="language-plaintext highlighter-rouge">spglib</code> is used for detecting the lattice symmetry. It should be obvious that unless one has really dense 3D-scalar fields, accurate symmetrization in real space would be a bad idea.</p> <p>Symmetrization method based on argument; default is <code class="language-plaintext highlighter-rouge">reciprocal</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">symmetrize_field</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Symmetrize a field according to crystal symmetry.
    Uses either real space or reciprocal space symmetrization based on initialization.

    Args:
        field: Scalar field with shape (nx, ny, nz) or vector field with shape (nx, ny, nz, 3)
        field_name: Name of field for logging

    Returns:
        symmetrized_field: Field with same shape as input but symmetrized
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">symmetrization_method</span> <span class="o">==</span> <span class="n">SymmetrizationMethod</span><span class="p">.</span><span class="n">RECIPROCAL</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_reciprocal_symmetrize</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">field_name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_real_symmetrize</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">field_name</span><span class="p">)</span>
</code></pre></div></div> <p>If we select real space symmetrization:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_real_symmetrize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Traditional symmetrization using averaging of symmetry-equivalent points in real space.
    </span><span class="sh">"""</span>
    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Starting real-space symmetrization of </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Store original field for validation
</span>    <span class="n">original_field</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>

    <span class="c1"># Get the shape and dimensions
</span>    <span class="n">field_shape</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">spatial_dims</span> <span class="o">=</span> <span class="n">field_shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">component_dims</span> <span class="o">=</span> <span class="n">field_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>  <span class="c1"># Empty for scalar field, (3,) for vector
</span>    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">spatial_dims</span>
    <span class="n">n_ops</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">)</span>

    <span class="c1"># Create fractional grid coordinates
</span>    <span class="n">grid_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">indices</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">T</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>

    <span class="c1"># Initialize array to accumulate field values
</span>    <span class="n">num_points</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid_points</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">component_dims</span><span class="p">:</span>
        <span class="n">sym_field_values</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">num_points</span><span class="p">,</span> <span class="n">n_ops</span><span class="p">)</span> <span class="o">+</span> <span class="n">component_dims</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sym_field_values</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">num_points</span><span class="p">,</span> <span class="n">n_ops</span><span class="p">))</span>

    <span class="c1"># Grid for interpolation
</span>    <span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">nz</span><span class="p">))</span>

    <span class="c1"># Reshape field for interpolation
</span>    <span class="n">field_reshaped</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">spatial_dims</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

    <span class="c1"># Apply symmetry operations
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">translations</span><span class="p">)):</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n_ops</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Processing symmetry operation </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">n_ops</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

        <span class="c1"># Apply rotation and translation to fractional coordinates
</span>        <span class="n">transformed_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid_points</span> <span class="o">@</span> <span class="n">rot</span><span class="p">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">trans</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.0</span>

        <span class="c1"># Convert fractional coordinates to grid indices
</span>        <span class="n">transformed_indices</span> <span class="o">=</span> <span class="n">transformed_coords</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>

        <span class="c1"># Ensure indices are within the grid
</span>        <span class="n">transformed_indices</span> <span class="o">%=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>

        <span class="c1"># Interpolate field values at transformed positions
</span>        <span class="n">field_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">field_reshaped</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nf">interpn</span><span class="p">(</span>
                <span class="n">grid</span><span class="p">,</span>
                <span class="n">field_reshaped</span><span class="p">[...,</span> <span class="n">comp</span><span class="p">],</span>
                <span class="n">transformed_indices</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="sh">"</span><span class="s">linear</span><span class="sh">"</span><span class="p">,</span>
                <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">field_values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># Stack component values
</span>        <span class="n">field_values</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span><span class="n">field_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># If scalar field, squeeze the last dimension
</span>        <span class="k">if</span> <span class="n">field_values</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">field_values</span> <span class="o">=</span> <span class="n">field_values</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">sym_field_values</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">...]</span> <span class="o">=</span> <span class="n">field_values</span>

    <span class="c1"># Average over symmetry operations
</span>    <span class="n">sym_field</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">sym_field_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Reshape symmetrized field back to original shape
</span>    <span class="n">sym_field</span> <span class="o">=</span> <span class="n">sym_field</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">field_shape</span><span class="p">)</span>

    <span class="c1"># Validate the symmetrized field
</span>    <span class="n">self</span><span class="p">.</span><span class="nf">validate_field_properties</span><span class="p">(</span><span class="n">sym_field</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">original_field</span><span class="p">)</span>

    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Completed real-space symmetrization of </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sym_field</span>
</code></pre></div></div> <p>If we select reciprocal space symmetrization:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_reciprocal_symmetrize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Symmetrization in reciprocal space, similar to VASP</span><span class="sh">'</span><span class="s">s approach.
    </span><span class="sh">"""</span>
    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Starting reciprocal-space symmetrization of </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Store original field for validation
</span>    <span class="n">original_field</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>

    <span class="c1"># Transform to reciprocal space
</span>    <span class="n">field_reciprocal</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_to_reciprocal_space</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>

    <span class="c1"># Get reciprocal lattice vectors
</span>    <span class="n">recip_vecs</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get_reciprocal_vectors</span><span class="p">()</span>

    <span class="c1"># Get grid dimensions
</span>    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># Create reciprocal space grid
</span>    <span class="n">kx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">fftfreq</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="o">*</span> <span class="n">nx</span>  <span class="c1"># Scaled to match grid points
</span>    <span class="n">ky</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">fftfreq</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="o">*</span> <span class="n">ny</span>
    <span class="n">kz</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">fftfreq</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span> <span class="o">*</span> <span class="n">nz</span>

    <span class="c1"># Create meshgrid of k-points
</span>    <span class="n">kgrid</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">meshgrid</span><span class="p">(</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">kz</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="sh">"</span><span class="s">ij</span><span class="sh">"</span><span class="p">))</span>

    <span class="c1"># Initialize symmetrized field in reciprocal space
</span>    <span class="n">sym_field_reciprocal</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">field_reciprocal</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">field_reciprocal</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Apply symmetry operations in reciprocal space
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">translations</span><span class="p">)):</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Processing symmetry operation </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span>
            <span class="p">)</span>

        <span class="c1"># Rotate k-points
</span>        <span class="n">rot_kgrid</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">einsum</span><span class="p">(</span><span class="sh">"</span><span class="s">ij,jpqr-&gt;ipqr</span><span class="sh">"</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">)</span>

        <span class="c1"># Find corresponding indices in the FFT grid
</span>        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">rot_kgrid</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Apply periodic boundary conditions
</span>        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">%</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])[:,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>

        <span class="c1"># Compute phase factors from translations
</span>        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span>
            <span class="o">-</span><span class="mf">2j</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">trans</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">kgrid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Accumulate symmetrized components
</span>        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">iz</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">],</span>
                        <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">],</span>
                        <span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">sym_field_reciprocal</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">field_reciprocal</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">phase</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>

    <span class="c1"># Average by weights
</span>    <span class="n">mask</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">sym_field_reciprocal</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/=</span> <span class="n">weights</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

    <span class="c1"># Transform back to real space
</span>    <span class="n">sym_field</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_to_real_space</span><span class="p">(</span><span class="n">sym_field_reciprocal</span><span class="p">)</span>

    <span class="c1"># Ensure result is real
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">sym_field</span><span class="p">.</span><span class="n">imag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">warning</span><span class="p">(</span><span class="sh">"</span><span class="s">Symmetrized field has non-zero imaginary components</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">sym_field</span> <span class="o">=</span> <span class="n">sym_field</span><span class="p">.</span><span class="n">real</span>

    <span class="c1"># Validate the symmetrized field
</span>    <span class="n">self</span><span class="p">.</span><span class="nf">validate_field_properties</span><span class="p">(</span><span class="n">sym_field</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">original_field</span><span class="p">)</span>

    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Completed reciprocal-space symmetrization of </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sym_field</span>
</code></pre></div></div> <p>It should be made sure that the integral quantities are conserved before and after symmetrization, in addition to whether the scalar field obey ,symmetrization in different regions: <code class="language-plaintext highlighter-rouge">core</code>, <code class="language-plaintext highlighter-rouge">bonding</code>, <code class="language-plaintext highlighter-rouge">interstitial</code>, because even if the scalar field is sampled uniformly, the constituing wavefunctions/wannier-functions are most definitely not.</p> <p>So,</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Validate symmetry with spatial analysis
</span><span class="n">self</span><span class="p">.</span><span class="nf">validate_symmetry</span><span class="p">(</span><span class="n">density</span><span class="p">,</span> <span class="sh">"</span><span class="s">density</span><span class="sh">"</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">validate_symmetry</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="sh">"</span><span class="s">kinetic energy density</span><span class="sh">"</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">validate_symmetry</span><span class="p">(</span><span class="n">grad_density</span><span class="p">,</span> <span class="sh">"</span><span class="s">density gradient</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>which calls upon the functions that validate symmetry and field properties</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">validate_symmetry</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Check if field obeys crystal symmetry, with spatial analysis relative to atomic positions.
    </span><span class="sh">"""</span>
    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Validating symmetry of </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Get field shape and dimensions
</span>    <span class="n">field_shape</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">spatial_dims</span> <span class="o">=</span> <span class="n">field_shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">spatial_dims</span>

    <span class="c1"># Create fractional grid coordinates
</span>    <span class="n">grid_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">indices</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">T</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>

    <span class="c1"># Sample subset of points for validation
</span>    <span class="n">num_points</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid_points</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">num_points</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">sampled_points</span> <span class="o">=</span> <span class="n">grid_points</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

    <span class="c1"># For scalar or vector fields, reshape as needed
</span>    <span class="n">field_reshaped</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">spatial_dims</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

    <span class="c1"># Grid for interpolation
</span>    <span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">nz</span><span class="p">))</span>

    <span class="c1"># Track violations by region
</span>    <span class="n">violations</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sh">"</span><span class="s">core</span><span class="sh">"</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># Within 1Å of nuclei
</span>        <span class="sh">"</span><span class="s">bonding</span><span class="sh">"</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># 1-2Å from nuclei
</span>        <span class="sh">"</span><span class="s">interstitial</span><span class="sh">"</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># &gt;2Å from nuclei
</span>    <span class="p">}</span>
    <span class="n">max_violation</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># For each sampled point, check symmetry
</span>    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">sampled_points</span><span class="p">):</span>
        <span class="c1"># Calculate distance to nearest atom
</span>        <span class="n">dist_to_atom</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_compute_distance_to_atoms</span><span class="p">(</span>
            <span class="n">point</span> <span class="o">*</span> <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">],</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Check symmetry violation
</span>        <span class="n">field_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rot</span><span class="p">,</span> <span class="n">trans</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rotations</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">translations</span><span class="p">):</span>
            <span class="n">transformed_point</span> <span class="o">=</span> <span class="p">(</span><span class="n">rot</span> <span class="o">@</span> <span class="n">point</span> <span class="o">+</span> <span class="n">trans</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.0</span>
            <span class="n">transformed_indices</span> <span class="o">=</span> <span class="n">transformed_point</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>
            <span class="n">transformed_indices</span> <span class="o">%=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">])</span>

            <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">field_reshaped</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nf">interpn</span><span class="p">(</span>
                    <span class="n">grid</span><span class="p">,</span>
                    <span class="n">field_reshaped</span><span class="p">[...,</span> <span class="n">comp</span><span class="p">],</span>
                    <span class="n">transformed_indices</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                    <span class="n">method</span><span class="o">=</span><span class="sh">"</span><span class="s">linear</span><span class="sh">"</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">field_values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">field_values</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">field_values</span><span class="p">)</span>
        <span class="n">max_diff</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">ptp</span><span class="p">(</span><span class="n">field_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">max_violation</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_violation</span><span class="p">,</span> <span class="n">max_diff</span><span class="p">)</span>
</code></pre></div></div> <p><strong>AND</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">validate_field_properties</span><span class="p">(</span>
    <span class="n">self</span><span class="p">,</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">original_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Validate physical properties of a field.
    </span><span class="sh">"""</span>
    <span class="c1"># Check for NaN or infinite values
</span>    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="p">.</span><span class="nf">isfinite</span><span class="p">(</span><span class="n">field</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s"> contains NaN or infinite values</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Add unit-aware validation
</span>    <span class="k">if</span> <span class="n">field_name</span> <span class="o">==</span> <span class="sh">"</span><span class="s">density</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="n">field</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Negative values found in </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s"> range: [</span><span class="si">{</span><span class="n">field</span><span class="p">.</span><span class="nf">min</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">e</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">field</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">e</span><span class="si">}</span><span class="s">] e/Å³</span><span class="sh">"</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">field_name</span> <span class="o">==</span> <span class="sh">"</span><span class="s">kinetic energy density</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="n">field</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Negative values found in </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s"> range: [</span><span class="si">{</span><span class="n">field</span><span class="p">.</span><span class="nf">min</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">e</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">field</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">e</span><span class="si">}</span><span class="s">] eV/Å³</span><span class="sh">"</span>
        <span class="p">)</span>

    <span class="c1"># Check total integral conservation
</span>    <span class="k">if</span> <span class="n">original_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">det</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">atoms</span><span class="p">.</span><span class="n">cell</span><span class="p">))</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">dV</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">nz</span><span class="p">)</span>

        <span class="n">total_orig</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">original_field</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV</span>
        <span class="n">total_new</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV</span>

        <span class="n">relative_diff</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nf">abs</span><span class="p">(</span><span class="n">total_orig</span> <span class="o">-</span> <span class="n">total_new</span><span class="p">)</span> <span class="o">/</span> <span class="nf">abs</span><span class="p">(</span><span class="n">total_orig</span><span class="p">)</span>
            <span class="k">if</span> <span class="nf">abs</span><span class="p">(</span><span class="n">total_orig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-10</span>
            <span class="k">else</span> <span class="mf">0.0</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">relative_diff</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Total </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s"> not conserved after symmetrization. </span><span class="sh">"</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Relative difference: </span><span class="si">{</span><span class="n">relative_diff</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Total </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s"> conserved after symmetrization. </span><span class="sh">"</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Relative difference: </span><span class="si">{</span><span class="n">relative_diff</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span>
            <span class="p">)</span>
</code></pre></div></div> <h3 id="calculating-elfr">Calculating \(ELF(r)\):</h3> <p>Finally, calculating ELF, which is straightforward:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">Computing ELF...</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Apply density threshold to avoid numerical issues
</span><span class="n">density_threshold</span> <span class="o">=</span> <span class="mf">1e-6</span>  <span class="c1"># e/Å³
</span><span class="n">mask</span> <span class="o">=</span> <span class="n">density</span> <span class="o">&gt;</span> <span class="n">density_threshold</span>

<span class="c1"># Calculate uniform electron gas kinetic energy density
# Following VASP's approach with same prefactors
</span><span class="n">D_h</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
<span class="n">D_h</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>

<span class="c1"># Calculate Pauli kinetic energy term
</span><span class="n">grad_density_norm</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">grad_density</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">tau_w</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
<span class="n">tau_w</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_density_norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">8.0</span> <span class="o">*</span> <span class="n">density</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

<span class="c1"># Calculate D = τ - τ_w
</span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">tau</span> <span class="o">-</span> <span class="n">tau_w</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="c1"># Initialize ELF array (starting from 0.0, not 0.5)
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>

<span class="c1"># Compute dimensionless χ = D/D_h
</span><span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
<span class="n">chi</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="n">D_h</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

<span class="c1"># Compute ELF
</span><span class="n">elf</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">chi</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div> <p>Using a <code class="language-plaintext highlighter-rouge">threshold</code>, masking values with <code class="language-plaintext highlighter-rouge">mask</code> seems to be important for stable values.</p> <h3 id="writing-scalar-fields-fr">Writing scalar fields \(F(r)\):</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">self</span><span class="p">.</span><span class="nf">write_field_xsf</span><span class="p">(</span><span class="sh">"</span><span class="s">density.xsf</span><span class="sh">"</span><span class="p">,</span> <span class="n">density</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">write_field_xsf</span><span class="p">(</span><span class="sh">"</span><span class="s">tau.xsf</span><span class="sh">"</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">write_field_xsf</span><span class="p">(</span><span class="sh">"</span><span class="s">tau_w.xsf</span><span class="sh">"</span><span class="p">,</span> <span class="n">tau_w</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">write_field_xsf</span><span class="p">(</span><span class="sh">"</span><span class="s">D_h.xsf</span><span class="sh">"</span><span class="p">,</span> <span class="n">D_h</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="nf">write_field_xsf</span><span class="p">(</span><span class="sh">"</span><span class="s">ELF.xsf</span><span class="sh">"</span><span class="p">,</span> <span class="n">elf</span><span class="p">)</span>
</code></pre></div></div> <p>We make use of ASE’s write function:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">write_field_xsf</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Write a field to an XSF file for visualization.</span><span class="sh">"""</span>
    <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Writing field to file: </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">write</span><span class="p">(</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">self</span><span class="p">.</span><span class="n">atoms</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="sh">"</span><span class="s">xsf</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
        <span class="n">origin</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span>
        <span class="n">span_vectors</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">span_vectors</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></div> <h3 id="elf-obtained-from-w_nr">ELF obtained from \(w_n(r)\):</h3> <p>A good example is \(\mathrm{CeO_2}\) where Cerium is supposed to have +4 and not +3 formal oxidation state. So the \(ELF(r)\) field value near Cerium across all cross sections should be minimal.</p> <div class="l-page"> <iframe src="/assets/plotly/elf_plot.html" frameborder="0" scrolling="no" height="50%" width="30%" style="border: 1px dashed grey;"></iframe> </div> <h3 id="conclusion"><strong>Conclusion</strong></h3> <p>Calculating the Electron Localization Function (ELF) using Wannier functions provides a localized perspective on electron localization, anc can potentially offer new insights into chemical bonding and electron pairing. Normalization, phase alignment, and inclusion of cross terms need to be carefully addressed. .. <em>Ongoing</em> …</p> <h3 id="references"><strong>References</strong></h3> <ol> <li>Becke, A. D., &amp; Edgecombe, K. E. (1990). A simple measure of electron localization in atomic and molecular systems. <em>The Journal of Chemical Physics</em>, 92(9), 5397–5403.</li> <li>Silvi, B., &amp; Savin, A. (1994). Classification of chemical bonds based on topological analysis of electron localization functions. <em>Nature</em>, 371(6499), 683–686.</li> <li>Kohn, W., &amp; Sham, L. J. (1965). Self-consistent equations including exchange and correlation effects. <em>Physical Review</em>, 140(4A), A1133.</li> <li>Marzari, N., Mostofi, A. A., Yates, J. R., Souza, I., &amp; Vanderbilt, D. (2012). Maximally localized Wannier functions: Theory and applications. <em>Reviews of Modern Physics</em>, 84(4), 1419–1475.</li> <li>Bader, R. F. W. (1990). <em>Atoms in Molecules: A Quantum Theory</em>. Oxford University Press.</li> <li>Yang, W., &amp; Parr, R. G. (1985). Hardness, softness, and the Fukui function in the electronic theory of metals and catalysis. <em>Proceedings of the National Academy of Sciences</em>, 82(20), 6723–6726.</li> <li>Silvi, B., &amp; Gatti, C. (2000). Electron localization function along a bond and atomic shell structure in solids. <em>The Journal of Physical Chemistry A</em>, 104(13), 2627–2635.</li> <li>Henkelman, G., Arnaldsson, A., &amp; Jónsson, H. (2006). A fast and robust algorithm for Bader decomposition of charge density. <em>Computational Materials Science</em>, 36(3), 354–360.</li> </ol> </div> </article> </div> </div> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Utkarsh Singh. Last updated: January 16, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>